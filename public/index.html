<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cross-Chain Messaging Prototype</title>
    <script src="https://cdn.jsdelivr.net/npm/web3@1.10.4/dist/web3.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .main-content {
            padding: 40px;
        }

        .status-bar {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 30px;
            border-left: 4px solid #007bff;
        }

        .status-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .status-item:last-child {
            margin-bottom: 0;
        }

        .status-label {
            font-weight: 600;
            color: #495057;
        }

        .status-value {
            color: #007bff;
            font-family: monospace;
        }

        .section {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            border: 1px solid #e9ecef;
        }

        .section h2 {
            color: #2c3e50;
            margin-bottom: 20px;
            font-size: 1.5rem;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #495057;
        }

        .form-group input, .form-group select, .form-group textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.3s;
        }

        .form-group input:focus, .form-group select:focus, .form-group textarea:focus {
            outline: none;
            border-color: #007bff;
        }

        .btn {
            background: linear-gradient(135deg, #007bff 0%, #0056b3 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            margin-right: 10px;
            margin-bottom: 10px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,123,255,0.3);
        }

        .btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
        }

        .btn-success {
            background: linear-gradient(135deg, #28a745 0%, #1e7e34 100%);
        }

        .btn-danger {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
        }

        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
        }

        .log-container {
            background: #1e1e1e;
            color: #00ff00;
            padding: 20px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            max-height: 300px;
            overflow-y: auto;
            margin-top: 20px;
        }

        .log-entry {
            margin-bottom: 5px;
            padding: 5px;
            border-left: 3px solid #00ff00;
            padding-left: 10px;
        }

        .log-error {
            color: #ff6b6b;
            border-left-color: #ff6b6b;
        }

        .log-success {
            color: #51cf66;
            border-left-color: #51cf66;
        }

        .log-info {
            color: #74c0fc;
            border-left-color: #74c0fc;
        }

        .alert {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .alert-warning {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
        }

        .alert-info {
            background: #d1ecf1;
            border: 1px solid #bee5eb;
            color: #0c5460;
        }

        .status-indicator {
            margin-top: 10px;
            padding: 8px;
            border-radius: 4px;
            font-size: 0.9rem;
            text-align: center;
        }

        .status-indicator.success {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }

        .status-indicator.error {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
        }

        .status-indicator.loading {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
        }

        code {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 8px 12px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            display: block;
            margin: 10px 0;
            color: #495057;
        }

        h3 {
            color: #495057;
            font-size: 1.1rem;
            margin-bottom: 10px;
        }

        ul {
            margin: 10px 0;
            padding-left: 20px;
        }

        ul li {
            margin: 5px 0;
            font-size: 0.9rem;
        }

        .message-list {
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 15px;
            background: #f8f9fa;
            max-height: 200px;
            overflow-y: auto;
        }

        .message-item {
            padding: 10px;
            margin: 5px 0;
            border-radius: 6px;
            background: white;
            border-left: 4px solid #007bff;
            font-size: 0.9rem;
        }

        .message-item.pending {
            border-left-color: #ffc107;
        }

        .message-item.success {
            border-left-color: #28a745;
        }

        .message-item.failed {
            border-left-color: #dc3545;
        }

        .chain-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: bold;
            margin: 0 5px;
        }

        .chain-ethereum {
            background: #627eea;
            color: white;
        }

        .chain-polygon {
            background: #8247e5;
            color: white;
        }

        .chain-bsc {
            background: #f3ba2f;
            color: black;
        }

        .chain-arbitrum {
            background: #28a0f0;
            color: white;
        }

        @media (max-width: 768px) {
            .grid {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .main-content {
                padding: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🌉 Cross-Chain Messaging</h1>
            <p>Test and interact with the cross-chain messaging prototype</p>
        </div>

        <div class="main-content">
            <div class="section">
                <h2>🚀 Quick Setup Guide</h2>
                <div class="alert alert-info">
                    <strong>📋 Complete Setup Process:</strong> Follow these steps to get everything running!
                </div>
                
                <div class="grid">
                    <div>
                        <h3>Step 1: Start Hardhat Node</h3>
                        <p>Run this command in your terminal:</p>
                        <code>npx hardhat node</code>
                        <button class="btn btn-secondary" onclick="checkNodeStatus()">Check Node Status</button>
                        <div id="nodeStatusIndicator" class="status-indicator"></div>
                    </div>
                    
                    <div>
                        <h3>Step 2: Deploy Contracts</h3>
                        <p>Run this command in another terminal:</p>
                        <code>npx hardhat run scripts/deploy.js --network localhost</code>
                        <button class="btn btn-secondary" onclick="tryFetchContractAddresses()">Auto-Detect Addresses</button>
                        <div id="deployStatusIndicator" class="status-indicator"></div>
                    </div>
                </div>
                
                <div class="grid">
                    <div>
                        <h3>Step 3: Connect MetaMask</h3>
                        <p>Add Hardhat network to MetaMask:</p>
                        <ul>
                            <li><strong>Network Name:</strong> Hardhat</li>
                            <li><strong>RPC URL:</strong> http://localhost:8545</li>
                            <li><strong>Chain ID:</strong> 31337</li>
                            <li><strong>Currency:</strong> ETH</li>
                        </ul>
                        <button class="btn" onclick="addHardhatNetwork()">Add Hardhat Network</button>
                        <button class="btn btn-secondary" onclick="addSepoliaNetwork()">Add Sepolia Network</button>
                    </div>
                    
                    <div>
                        <h3>Step 4: Import Test Account</h3>
                        <p>Import Hardhat test account #0:</p>
                        <code>0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80</code>
                        <button class="btn btn-secondary" onclick="copyTestAccount()">Copy Private Key</button>
                        <div id="accountCopyIndicator" class="status-indicator"></div>
                    </div>
                </div>
            </div>

            <div class="status-bar">
                <div class="status-item">
                    <span class="status-label">🔗 Hardhat Node:</span>
                    <span class="status-value" id="nodeStatus">Unknown</span>
                </div>
                <div class="status-item">
                    <span class="status-label">👛 Wallet:</span>
                    <span class="status-value" id="walletStatus">Not Connected</span>
                </div>
                <div class="status-item">
                    <span class="status-label">🌐 Network:</span>
                    <span class="status-value" id="networkStatus">Unknown</span>
                </div>
                <div class="status-item">
                    <span class="status-label">📜 Contracts:</span>
                    <span class="status-value" id="contractStatus">Not Loaded</span>
                </div>
            </div>

            <div class="grid">
                <div class="section">
                    <h2>🔧 Setup</h2>
                    
                    <div class="form-group">
                        <label for="messengerAddress">CrossChainMessenger Address:</label>
                        <input type="text" id="messengerAddress" placeholder="0x..." />
                    </div>
                    
                    <div class="form-group">
                        <label for="testTargetAddress">TestTarget Address:</label>
                        <input type="text" id="testTargetAddress" placeholder="0x..." />
                    </div>
                    
                    <button class="btn" onclick="connectWallet()">Connect Wallet</button>
                    <button class="btn btn-secondary" onclick="loadContracts()">Load Contracts</button>
                </div>

                <div class="section">
                    <h2>📊 Contract State</h2>
                    
                    <div class="form-group">
                        <label>TestTarget Counter:</label>
                        <input type="text" id="counterValue" readonly />
                    </div>
                    
                    <div class="form-group">
                        <label>Stored Value:</label>
                        <input type="text" id="storedValue" readonly />
                    </div>
                    
                    <button class="btn btn-secondary" onclick="refreshState()">Refresh State</button>
                </div>
            </div>

            <div class="section">
                <h2>📨 Cross-Chain Message Hub</h2>
                
                <div class="alert alert-info">
                    <strong>🌉 Cross-Chain Demo:</strong> This simulates sending messages between different blockchain networks. In production, relayers would process messages across real chains.
                </div>
                
                <div class="grid">
                    <div>
                        <div class="form-group">
                            <label for="sourceChain">Source Chain (Current):</label>
                            <select id="sourceChain">
                                <option value="31337">🏠 Hardhat Localhost</option>
                                <option value="1">🔷 Ethereum Mainnet</option>
                                <option value="137">🟣 Polygon</option>
                                <option value="56">🟡 BSC</option>
                                <option value="42161">🔵 Arbitrum</option>
                                <option value="11155111">🧪 Sepolia Testnet</option>
                            </select>
                        </div>
                        
                        <div class="form-group">
                            <label for="targetChain">Target Chain (Destination):</label>
                            <select id="targetChain">
                                <option value="137">🟣 Polygon</option>
                                <option value="31337">🏠 Hardhat Localhost</option>
                                <option value="1">🔷 Ethereum Mainnet</option>
                                <option value="56">🟡 BSC</option>
                                <option value="42161">🔵 Arbitrum</option>
                                <option value="11155111">🧪 Sepolia Testnet</option>
                            </select>
                        </div>
                        
                        <div class="form-group">
                            <label for="messageType">Message Type:</label>
                            <select id="messageType" onchange="updateMessageForm()">
                                <option value="setCounter">Set Counter</option>
                                <option value="incrementCounter">Increment Counter</option>
                                <option value="storeValue">Store Value</option>
                                <option value="customCall">Custom Contract Call</option>
                            </select>
                        </div>
                    </div>
                    
                    <div>
                        <div class="form-group" id="valueInput">
                            <label for="messageValue">Value:</label>
                            <input type="number" id="messageValue" placeholder="Enter value" />
                        </div>
                        
                        <div class="form-group" id="customCallInput" style="display: none;">
                            <label for="customCallData">Custom Call Data:</label>
                            <input type="text" id="customCallData" placeholder="0x..." />
                        </div>
                        
                        <div class="form-group">
                            <label for="gasLimit">Gas Limit:</label>
                            <input type="number" id="gasLimit" value="200000" />
                        </div>
                        
                        <div class="form-group">
                            <label>Estimated Cost:</label>
                            <input type="text" id="estimatedCost" readonly placeholder="~$0.50" />
                        </div>
                    </div>
                </div>
                
                <div class="grid">
                    <button class="btn btn-success" onclick="sendCrossChainMessage()">🚀 Send Cross-Chain Message</button>
                    <button class="btn btn-secondary" onclick="simulateFullWorkflow()">🎭 Simulate Full Workflow</button>
                    <button class="btn" onclick="sendLocalMessage()">📍 Send Local Message</button>
                </div>
            </div>

            <div class="section">
                <h2>🔄 Cross-Chain Message Status</h2>
                
                <div class="grid">
                    <div>
                        <h3>📤 Outgoing Messages</h3>
                        <div id="outgoingMessages" class="message-list">
                            <div class="message-item">No messages sent yet</div>
                        </div>
                    </div>
                    
                    <div>
                        <h3>📥 Incoming Messages</h3>
                        <div id="incomingMessages" class="message-list">
                            <div class="message-item">No messages received yet</div>
                        </div>
                    </div>
                </div>
                
                <button class="btn btn-secondary" onclick="refreshMessageStatus()">🔄 Refresh Status</button>
            </div>

            <div class="section">
                <h2>🔐 Admin Functions</h2>
                
                <div class="grid">
                    <div>
                        <div class="form-group">
                            <label for="relayerAddress">Relayer Address:</label>
                            <input type="text" id="relayerAddress" placeholder="0x..." />
                        </div>
                        
                        <button class="btn" onclick="addRelayer()">Add Relayer</button>
                        <button class="btn btn-danger" onclick="removeRelayer()">Remove Relayer</button>
                    </div>
                    
                    <div>
                        <div class="form-group">
                            <label for="chainId">Chain ID:</label>
                            <input type="number" id="chainId" placeholder="1, 137, 56..." />
                        </div>
                        
                        <button class="btn" onclick="enableChain()">Enable Chain</button>
                        <button class="btn btn-danger" onclick="disableChain()">Disable Chain</button>
                    </div>
                </div>
            </div>

            <div class="section">
                <h2>📋 Activity Log</h2>
                <button class="btn btn-secondary" onclick="clearLog()">Clear Log</button>
                <div class="log-container" id="logContainer">
                    <div class="log-entry log-info">Welcome to Cross-Chain Messaging Interface</div>
                    <div class="log-entry log-info">Connect your wallet and load contracts to get started</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let web3;
        let account;
        let messengerContract;
        let testTargetContract;

        const MESSENGER_ABI = [
            {
                "inputs": [],
                "name": "addRelayer",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [{"internalType": "address","name": "relayer","type": "address"}],
                "name": "addRelayer",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [{"internalType": "uint256","name": "chainId","type": "uint256"}],
                "name": "enableChain",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [{"internalType": "uint256","name": "chainId","type": "uint256"}],
                "name": "disableChain",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [{"internalType": "address","name": "relayer","type": "address"}],
                "name": "removeRelayer",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {"internalType": "uint256","name": "targetChain","type": "uint256"},
                    {"internalType": "address","name": "targetContract","type": "address"},
                    {"internalType": "bytes","name": "payload","type": "bytes"},
                    {"internalType": "uint256","name": "gasLimit","type": "uint256"}
                ],
                "name": "sendMessage",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {"internalType": "bytes32","name": "messageId","type": "bytes32"},
                    {"internalType": "uint256","name": "sourceChain","type": "uint256"},
                    {"internalType": "address","name": "sender","type": "address"},
                    {"internalType": "address","name": "targetContract","type": "address"},
                    {"internalType": "bytes","name": "payload","type": "bytes"},
                    {"internalType": "uint256","name": "nonce","type": "uint256"},
                    {"internalType": "uint256","name": "gasLimit","type": "uint256"},
                    {"internalType": "uint256","name": "expiry","type": "uint256"},
                    {"internalType": "bytes","name": "signature","type": "bytes"}
                ],
                "name": "processMessage",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [{"internalType": "uint256","name": "chainId","type": "uint256"}],
                "name": "getNextNonce",
                "outputs": [{"internalType": "uint256","name": "","type": "uint256"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "anonymous": false,
                "inputs": [
                    {"indexed": true,"internalType": "bytes32","name": "messageId","type": "bytes32"},
                    {"indexed": true,"internalType": "uint256","name": "targetChain","type": "uint256"},
                    {"indexed": true,"internalType": "address","name": "sender","type": "address"},
                    {"indexed": false,"internalType": "address","name": "targetContract","type": "address"},
                    {"indexed": false,"internalType": "bytes","name": "payload","type": "bytes"},
                    {"indexed": false,"internalType": "uint256","name": "nonce","type": "uint256"},
                    {"indexed": false,"internalType": "uint256","name": "gasLimit","type": "uint256"}
                ],
                "name": "MessageSent",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {"indexed": true,"internalType": "bytes32","name": "messageId","type": "bytes32"},
                    {"indexed": true,"internalType": "uint256","name": "sourceChain","type": "uint256"},
                    {"indexed": true,"internalType": "address","name": "sender","type": "address"},
                    {"indexed": false,"internalType": "address","name": "targetContract","type": "address"},
                    {"indexed": false,"internalType": "bool","name": "success","type": "bool"}
                ],
                "name": "MessageProcessed",
                "type": "event"
            }
        ];

        const TEST_TARGET_ABI = [
            {
                "inputs": [{"internalType": "uint256","name": "_counter","type": "uint256"}],
                "name": "setCounter",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "incrementCounter",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [{"internalType": "uint256","name": "_value","type": "uint256"}],
                "name": "storeValue",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "counter",
                "outputs": [{"internalType": "uint256","name": "","type": "uint256"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "storedValue",
                "outputs": [{"internalType": "uint256","name": "","type": "uint256"}],
                "stateMutability": "view",
                "type": "function"
            }
        ];

        async function connectWallet() {
            try {
                if (typeof window.ethereum !== 'undefined') {
                    web3 = new Web3(window.ethereum);
                    const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                    account = accounts[0];
                    
                    const networkId = await web3.eth.net.getId();
                    
                                    document.getElementById('walletStatus').textContent = `${account.substring(0, 6)}...${account.substring(38)}`;
                document.getElementById('walletStatus').style.color = '#28a745';
                document.getElementById('networkStatus').textContent = `Chain ID: ${networkId}`;
                
                if (networkId == 31337) {
                    document.getElementById('networkStatus').style.color = '#28a745';
                } else {
                    document.getElementById('networkStatus').style.color = '#ffc107';
                }
                
                logMessage('Wallet connected successfully', 'success');
                } else {
                    logMessage('MetaMask not detected. Please install MetaMask.', 'error');
                }
            } catch (error) {
                logMessage(`Error connecting wallet: ${error.message}`, 'error');
            }
        }

        async function loadContracts() {
            try {
                const messengerAddress = document.getElementById('messengerAddress').value;
                const testTargetAddress = document.getElementById('testTargetAddress').value;
                
                if (!messengerAddress || !testTargetAddress) {
                    logMessage('Please enter both contract addresses', 'error');
                    return;
                }
                
                messengerContract = new web3.eth.Contract(MESSENGER_ABI, messengerAddress);
                testTargetContract = new web3.eth.Contract(TEST_TARGET_ABI, testTargetAddress);
                
                document.getElementById('contractStatus').textContent = 'Loaded';
                document.getElementById('contractStatus').style.color = '#28a745';
                
                logMessage('Contracts loaded successfully', 'success');
                await refreshState();
            } catch (error) {
                logMessage(`Error loading contracts: ${error.message}`, 'error');
            }
        }

        async function refreshState() {
            try {
                if (!testTargetContract) {
                    logMessage('Please load contracts first', 'error');
                    return;
                }
                
                // Check if contract is deployed at the address
                const code = await web3.eth.getCode(testTargetContract.options.address);
                if (code === '0x') {
                    logMessage('TestTarget contract not deployed at the specified address', 'error');
                    return;
                }
                
                logMessage('Calling counter() method...', 'info');
                const counter = await testTargetContract.methods.counter().call();
                logMessage(`Counter value: ${counter}`, 'info');
                
                logMessage('Calling storedValue() method...', 'info');
                const storedValue = await testTargetContract.methods.storedValue().call();
                logMessage(`Stored value: ${storedValue}`, 'info');
                
                document.getElementById('counterValue').value = counter;
                document.getElementById('storedValue').value = storedValue;
                
                logMessage('Contract state refreshed successfully', 'success');
            } catch (error) {
                logMessage(`Error refreshing state: ${error.message}`, 'error');
                logMessage(`Contract address: ${testTargetContract?.options?.address}`, 'error');
                logMessage('Please check if the TestTarget contract is deployed correctly', 'error');
            }
        }

        function updateMessageForm() {
            const messageType = document.getElementById('messageType').value;
            const valueInput = document.getElementById('valueInput');
            const customCallInput = document.getElementById('customCallInput');
            
            if (messageType === 'incrementCounter') {
                valueInput.style.display = 'none';
                customCallInput.style.display = 'none';
            } else if (messageType === 'customCall') {
                valueInput.style.display = 'none';
                customCallInput.style.display = 'block';
            } else {
                valueInput.style.display = 'block';
                customCallInput.style.display = 'none';
            }
            
            updateEstimatedCost();
        }
        
        function updateEstimatedCost() {
            const sourceChain = document.getElementById('sourceChain').value;
            const targetChain = document.getElementById('targetChain').value;
            const gasLimit = document.getElementById('gasLimit').value;
            
            // Simulate cost calculation
            const gasCosts = {
                '1': 50,    // Ethereum - expensive
                '137': 0.1, // Polygon - cheap
                '56': 1,    // BSC - medium
                '42161': 2, // Arbitrum - low
                '31337': 0, // Hardhat - free
                '11155111': 5 // Sepolia - testnet
            };
            
            const sourceCost = (gasCosts[sourceChain] || 1) * (gasLimit / 21000);
            const targetCost = (gasCosts[targetChain] || 1) * (gasLimit / 21000);
            const relayerFee = 0.1; // Fixed relayer fee
            
            const totalCost = sourceCost + targetCost + relayerFee;
            document.getElementById('estimatedCost').value = `~$${totalCost.toFixed(2)}`;
        }
        
        // Global message tracking
        let messageCounter = 0;
        let pendingMessages = [];

        async function sendMessage() {
            try {
                if (!testTargetContract || !account) {
                    logMessage('Please connect wallet and load contracts first', 'error');
                    return;
                }
                
                // Check account balance
                const balance = await web3.eth.getBalance(account);
                const balanceEth = web3.utils.fromWei(balance, 'ether');
                logMessage(`Account balance: ${balanceEth} ETH`, 'info');
                
                if (parseFloat(balanceEth) < 0.01) {
                    logMessage('Warning: Low ETH balance. Make sure you have enough ETH for gas', 'error');
                }
                
                const targetChain = document.getElementById('targetChain').value;
                const messageType = document.getElementById('messageType').value;
                const messageValue = document.getElementById('messageValue').value;
                
                logMessage(`Executing ${messageType} directly on TestTarget contract...`, 'info');
                logMessage(`Contract address: ${testTargetContract.options.address}`, 'info');
                logMessage(`From account: ${account}`, 'info');
                
                let tx;
                
                try {
                    if (messageType === 'setCounter') {
                        if (!messageValue) {
                            logMessage('Please enter a value for setCounter', 'error');
                            return;
                        }
                        logMessage(`Calling setCounter(${messageValue})...`, 'info');
                        
                        // First test the call to make sure it works
                        logMessage('Testing setCounter call...', 'info');
                        await testTargetContract.methods.setCounter(messageValue).call({ from: account });
                        logMessage('Call test successful, sending transaction...', 'info');
                        
                        tx = await testTargetContract.methods.setCounter(messageValue).send({ 
                            from: account,
                            gas: 200000  // Fixed gas limit that works
                        });
                    } else if (messageType === 'incrementCounter') {
                        logMessage('Calling incrementCounter()...', 'info');
                        
                        logMessage('Testing incrementCounter call...', 'info');
                        await testTargetContract.methods.incrementCounter().call({ from: account });
                        logMessage('Call test successful, sending transaction...', 'info');
                        
                        tx = await testTargetContract.methods.incrementCounter().send({ 
                            from: account,
                            gas: 200000
                        });
                    } else if (messageType === 'storeValue') {
                        if (!messageValue) {
                            logMessage('Please enter a value for storeValue', 'error');
                            return;
                        }
                        logMessage(`Calling storeValue(${messageValue})...`, 'info');
                        
                        logMessage('Testing storeValue call...', 'info');
                        await testTargetContract.methods.storeValue(messageValue).call({ from: account });
                        logMessage('Call test successful, sending transaction...', 'info');
                        
                        tx = await testTargetContract.methods.storeValue(messageValue).send({ 
                            from: account,
                            gas: 200000
                        });
                    }
                    
                    logMessage(`Transaction successful! Hash: ${tx.transactionHash}`, 'success');
                    logMessage('Refreshing contract state...', 'info');
                    
                    // Auto-refresh state after successful transaction
                    setTimeout(async () => {
                        await refreshState();
                    }, 1000);
                    
                } catch (contractError) {
                    logMessage(`Contract call failed: ${contractError.message}`, 'error');
                    console.error('Contract error details:', contractError);
                    
                    // Try to get more specific error info
                    if (contractError.message.includes('revert')) {
                        logMessage('Transaction was reverted by the contract', 'error');
                    } else if (contractError.message.includes('gas')) {
                        logMessage('Gas-related error - try increasing gas limit', 'error');
                    } else if (contractError.message.includes('nonce')) {
                        logMessage('Nonce error - try refreshing and resending', 'error');
                    }
                }
                
            } catch (error) {
                logMessage(`Error executing message: ${error.message}`, 'error');
                logMessage('Check console for detailed error information', 'info');
                console.error('Detailed error:', error);
            }
        }

        async function simulateRelayerProcessing() {
            logMessage('Simulating relayer processing...', 'info');
            logMessage('In a real implementation, relayers would:', 'info');
            logMessage('1. Listen for MessageSent events', 'info');
            logMessage('2. Create and sign message proofs', 'info');
            logMessage('3. Call processMessage on target chain', 'info');
            logMessage('4. Handle gas estimation and retry logic', 'info');
            logMessage('Note: This demo runs on a single chain for simplicity', 'info');
        }

        async function addRelayer() {
            try {
                const relayerAddress = document.getElementById('relayerAddress').value;
                if (!relayerAddress) {
                    logMessage('Please enter relayer address', 'error');
                    return;
                }
                
                const tx = await messengerContract.methods.addRelayer(relayerAddress).send({ from: account });
                logMessage(`Relayer added! Transaction: ${tx.transactionHash}`, 'success');
            } catch (error) {
                logMessage(`Error adding relayer: ${error.message}`, 'error');
            }
        }

        async function removeRelayer() {
            try {
                const relayerAddress = document.getElementById('relayerAddress').value;
                if (!relayerAddress) {
                    logMessage('Please enter relayer address', 'error');
                    return;
                }
                
                const tx = await messengerContract.methods.removeRelayer(relayerAddress).send({ from: account });
                logMessage(`Relayer removed! Transaction: ${tx.transactionHash}`, 'success');
            } catch (error) {
                logMessage(`Error removing relayer: ${error.message}`, 'error');
            }
        }

        async function enableChain() {
            try {
                const chainId = document.getElementById('chainId').value;
                if (!chainId) {
                    logMessage('Please enter chain ID', 'error');
                    return;
                }
                
                const tx = await messengerContract.methods.enableChain(chainId).send({ from: account });
                logMessage(`Chain ${chainId} enabled! Transaction: ${tx.transactionHash}`, 'success');
            } catch (error) {
                logMessage(`Error enabling chain: ${error.message}`, 'error');
            }
        }

        async function disableChain() {
            try {
                const chainId = document.getElementById('chainId').value;
                if (!chainId) {
                    logMessage('Please enter chain ID', 'error');
                    return;
                }
                
                const tx = await messengerContract.methods.disableChain(chainId).send({ from: account });
                logMessage(`Chain ${chainId} disabled! Transaction: ${tx.transactionHash}`, 'success');
            } catch (error) {
                logMessage(`Error disabling chain: ${error.message}`, 'error');
            }
        }

        function logMessage(message, type = 'info') {
            const logContainer = document.getElementById('logContainer');
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry log-${type}`;
            logEntry.textContent = `[${timestamp}] ${message}`;
            logContainer.appendChild(logEntry);
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        function clearLog() {
            document.getElementById('logContainer').innerHTML = '';
            logMessage('Log cleared', 'info');
        }

        // Initialize form
        updateMessageForm();
        
        // Add event listeners for cost updates
        document.getElementById('sourceChain').addEventListener('change', updateEstimatedCost);
        document.getElementById('targetChain').addEventListener('change', updateEstimatedCost);
        document.getElementById('gasLimit').addEventListener('input', updateEstimatedCost);
        
        // New cross-chain functions
        async function sendCrossChainMessage() {
            try {
                const sourceChain = document.getElementById('sourceChain').value;
                const targetChain = document.getElementById('targetChain').value;
                const messageType = document.getElementById('messageType').value;
                const messageValue = document.getElementById('messageValue').value;
                
                if (sourceChain === targetChain) {
                    logMessage('⚠️ Source and target chains cannot be the same for cross-chain messaging', 'error');
                    return;
                }
                
                const messageId = ++messageCounter;
                const message = {
                    id: messageId,
                    sourceChain: getChainName(sourceChain),
                    targetChain: getChainName(targetChain),
                    type: messageType,
                    value: messageValue,
                    status: 'pending',
                    timestamp: new Date().toLocaleTimeString()
                };
                
                addOutgoingMessage(message);
                logMessage(`🚀 Cross-chain message initiated: ${sourceChain} → ${targetChain}`, 'success');
                logMessage(`📋 Message Type: ${messageType}, Value: ${messageValue}`, 'info');
                
                // Simulate cross-chain processing
                simulateMessageProcessing(message);
                
            } catch (error) {
                logMessage(`❌ Error sending cross-chain message: ${error.message}`, 'error');
            }
        }
        
        async function sendLocalMessage() {
            // Use the existing sendMessage function for local testing
            await sendMessage();
        }
        
        async function simulateFullWorkflow() {
            logMessage('🎭 Starting full cross-chain workflow simulation...', 'info');
            
            const steps = [
                '1️⃣ Creating cross-chain message...',
                '2️⃣ Signing message with relayer key...',
                '3️⃣ Broadcasting to source chain...',
                '4️⃣ Waiting for block confirmation...',
                '5️⃣ Relayer detecting message event...',
                '6️⃣ Generating merkle proof...',
                '7️⃣ Submitting to target chain...',
                '8️⃣ Target chain verification...',
                '9️⃣ Executing message on target...',
                '✅ Cross-chain message completed!'
            ];
            
            for (let i = 0; i < steps.length; i++) {
                setTimeout(() => {
                    logMessage(steps[i], 'info');
                }, i * 800);
            }
            
            // Simulate adding a completed message
            setTimeout(() => {
                const message = {
                    id: ++messageCounter,
                    sourceChain: 'Ethereum',
                    targetChain: 'Polygon',
                    type: 'setCounter',
                    value: '42',
                    status: 'success',
                    timestamp: new Date().toLocaleTimeString()
                };
                addIncomingMessage(message);
            }, 8000);
        }
        
        function simulateMessageProcessing(message) {
            // Simulate processing delay
            setTimeout(() => {
                message.status = 'relaying';
                updateMessageStatus(message);
                logMessage(`🔄 Message ${message.id} being processed by relayers...`, 'info');
            }, 2000);
            
            setTimeout(() => {
                message.status = 'success';
                updateMessageStatus(message);
                addIncomingMessage(message);
                logMessage(`✅ Message ${message.id} successfully delivered to ${message.targetChain}!`, 'success');
            }, 5000);
        }
        
        function addOutgoingMessage(message) {
            const container = document.getElementById('outgoingMessages');
            if (container.children[0]?.textContent === 'No messages sent yet') {
                container.innerHTML = '';
            }
            
            const messageElement = createMessageElement(message);
            container.appendChild(messageElement);
        }
        
        function addIncomingMessage(message) {
            const container = document.getElementById('incomingMessages');
            if (container.children[0]?.textContent === 'No messages received yet') {
                container.innerHTML = '';
            }
            
            const messageElement = createMessageElement(message);
            container.appendChild(messageElement);
        }
        
        function createMessageElement(message) {
            const div = document.createElement('div');
            div.className = `message-item ${message.status}`;
            div.id = `message-${message.id}`;
            div.innerHTML = `
                <div><strong>Message #${message.id}</strong> - ${message.type}</div>
                <div>
                    <span class="chain-badge">${message.sourceChain}</span> → 
                    <span class="chain-badge">${message.targetChain}</span>
                </div>
                <div>Value: ${message.value} | Status: ${message.status} | ${message.timestamp}</div>
            `;
            return div;
        }
        
        function updateMessageStatus(message) {
            const element = document.getElementById(`message-${message.id}`);
            if (element) {
                element.className = `message-item ${message.status}`;
                element.querySelector('div:last-child').textContent = 
                    `Value: ${message.value} | Status: ${message.status} | ${message.timestamp}`;
            }
        }
        
        function getChainName(chainId) {
            const names = {
                '1': 'Ethereum',
                '137': 'Polygon', 
                '56': 'BSC',
                '42161': 'Arbitrum',
                '31337': 'Hardhat',
                '11155111': 'Sepolia'
            };
            return names[chainId] || `Chain ${chainId}`;
        }
        
        function refreshMessageStatus() {
            logMessage('🔄 Refreshing message status...', 'info');
            // In a real app, this would query the blockchain for message states
            logMessage('✅ Message status refreshed', 'success');
        }

        // Auto-check node status on page load
        checkNodeStatus();

        // Helper functions for automation
        async function checkNodeStatus() {
            const indicator = document.getElementById('nodeStatusIndicator');
            const statusElement = document.getElementById('nodeStatus');
            
            try {
                indicator.className = 'status-indicator loading';
                indicator.textContent = 'Checking...';
                
                let rpcUrl = 'http://localhost:8545';
                let expectedChainId = '0x7a69'; // 31337 in hex for Hardhat
                let networkName = 'Hardhat node';
                
                // Check if we're on a testnet via MetaMask
                if (typeof window.ethereum !== 'undefined') {
                    try {
                        const chainId = await window.ethereum.request({ method: 'eth_chainId' });
                        if (chainId === '0xaa36a7') { // 11155111 in hex for Sepolia
                            rpcUrl = 'https://ethereum-sepolia-rpc.publicnode.com';
                            expectedChainId = '0xaa36a7';
                            networkName = 'Sepolia testnet';
                        }
                    } catch (e) {
                        // Fall back to Hardhat check
                    }
                }
                
                const response = await fetch(rpcUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        jsonrpc: '2.0',
                        method: 'eth_chainId',
                        params: [],
                        id: 1
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.result === expectedChainId) {
                        indicator.className = 'status-indicator success';
                        indicator.textContent = `✅ Connected to ${networkName}!`;
                        statusElement.textContent = 'Connected';
                        statusElement.style.color = '#28a745';
                        
                        // Auto-try to fetch contract addresses
                        setTimeout(() => tryFetchContractAddresses(), 1000);
                    } else {
                        throw new Error('Wrong network');
                    }
                } else {
                    throw new Error('Connection failed');
                }
            } catch (error) {
                indicator.className = 'status-indicator error';
                indicator.textContent = '❌ Network not available. Connect MetaMask or run: npx hardhat node';
                statusElement.textContent = 'Not Connected';
                statusElement.style.color = '#dc3545';
            }
        }

        async function tryFetchContractAddresses() {
            const indicator = document.getElementById('deployStatusIndicator');
            
            try {
                indicator.className = 'status-indicator loading';
                indicator.textContent = 'Checking for deployed contracts...';
                
                // Initialize Web3 connection
                let rpcUrl = 'http://localhost:8545';
                
                // Check if we're on a testnet via MetaMask
                if (typeof window.ethereum !== 'undefined') {
                    try {
                        const chainId = await window.ethereum.request({ method: 'eth_chainId' });
                        if (chainId === '0xaa36a7') { // 11155111 in hex for Sepolia
                            rpcUrl = 'https://ethereum-sepolia-rpc.publicnode.com';
                        }
                    } catch (e) {
                        // Fall back to Hardhat
                    }
                }
                
                const tempWeb3 = new Web3(rpcUrl);
                
                // Known contract addresses by network
                const KNOWN_ADDRESSES = {
                    31337: { // Hardhat Local
                        crossChainMessenger: '0x5FbDB2315678afecb367f032d93F642f64180aa3',
                        testTarget: '0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512'
                    },
                    11155111: { // Sepolia Testnet
                        crossChainMessenger: '0x3014b38b18ea56F34958702FbAC629594208CEFC',
                        testTarget: '0x22e3675dD5514A7659066Bc11DfE48c3A97B0B7B'
                    }
                };
                
                // Get current network
                const chainId = await tempWeb3.eth.getChainId();
                const knownAddresses = KNOWN_ADDRESSES[chainId];
                
                if (knownAddresses) {
                    // Use known addresses for this network
                    document.getElementById('messengerAddress').value = knownAddresses.crossChainMessenger;
                    document.getElementById('testTargetAddress').value = knownAddresses.testTarget;
                    
                    indicator.className = 'status-indicator success';
                    indicator.textContent = `✅ Contract addresses loaded for ${getChainName(chainId.toString())}!`;
                    
                    logMessage(`Loaded contract addresses for ${getChainName(chainId.toString())}!`, 'success');
                    logMessage(`CrossChainMessenger: ${knownAddresses.crossChainMessenger}`, 'info');
                    logMessage(`TestTarget: ${knownAddresses.testTarget}`, 'info');
                    
                    // Auto-load contracts
                    setTimeout(() => loadContracts(), 1000);
                    return;
                }
                
                // Fallback: Common deployment addresses (Hardhat deploys to these usually)
                const commonAddresses = [
                    '0x5FbDB2315678afecb367f032d93F642f64180aa3',
                    '0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512',
                    '0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0',
                    '0xCf7Ed3AccA5a467e9e704C703E8D87F634fB0Fc9'
                ];
                
                let messengerAddr = null;
                let testTargetAddr = null;
                
                // Check each address to see what's deployed
                for (const addr of commonAddresses) {
                    try {
                        const code = await tempWeb3.eth.getCode(addr);
                        if (code !== '0x') {
                            // Try to determine which contract this is
                            const contract = new tempWeb3.eth.Contract(TEST_TARGET_ABI, addr);
                            try {
                                await contract.methods.counter().call();
                                testTargetAddr = addr;
                                logMessage(`Found TestTarget at: ${addr}`, 'success');
                            } catch {
                                // Probably the messenger contract
                                messengerAddr = addr;
                                logMessage(`Found CrossChainMessenger at: ${addr}`, 'success');
                            }
                        }
                    } catch (e) {
                        // Continue checking other addresses
                    }
                }
                
                if (messengerAddr && testTargetAddr) {
                    document.getElementById('messengerAddress').value = messengerAddr;
                    document.getElementById('testTargetAddress').value = testTargetAddr;
                    
                    indicator.className = 'status-indicator success';
                    indicator.textContent = '✅ Contract addresses auto-detected!';
                    
                    logMessage('Contract addresses auto-populated!', 'success');
                    logMessage(`CrossChainMessenger: ${messengerAddr}`, 'info');
                    logMessage(`TestTarget: ${testTargetAddr}`, 'info');
                    
                    // Auto-load contracts
                    setTimeout(() => loadContracts(), 1000);
                    
                } else {
                    indicator.className = 'status-indicator error';
                    indicator.textContent = '❌ Contracts not found. Please deploy them first.';
                }
                
            } catch (error) {
                indicator.className = 'status-indicator error';
                indicator.textContent = '❌ Error checking contracts: ' + error.message;
            }
        }

        async function addHardhatNetwork() {
            try {
                if (typeof window.ethereum !== 'undefined') {
                    await window.ethereum.request({
                        method: 'wallet_addEthereumChain',
                        params: [{
                            chainId: '0x7a69', // 31337 in hex
                            chainName: 'Hardhat Local',
                            nativeCurrency: {
                                name: 'Ethereum',
                                symbol: 'ETH',
                                decimals: 18
                            },
                            rpcUrls: ['http://localhost:8545'],
                            blockExplorerUrls: null
                        }]
                    });
                    logMessage('✅ Hardhat network added to MetaMask!', 'success');
                } else {
                    logMessage('❌ MetaMask not detected', 'error');
                }
            } catch (error) {
                logMessage(`Error adding network: ${error.message}`, 'error');
            }
        }

        async function addSepoliaNetwork() {
            try {
                if (typeof window.ethereum !== 'undefined') {
                    await window.ethereum.request({
                        method: 'wallet_addEthereumChain',
                        params: [{
                            chainId: '0xaa36a7', // 11155111 in hex
                            chainName: 'Sepolia Testnet',
                            nativeCurrency: {
                                name: 'Ethereum',
                                symbol: 'ETH',
                                decimals: 18
                            },
                            rpcUrls: ['https://ethereum-sepolia-rpc.publicnode.com'],
                            blockExplorerUrls: ['https://sepolia.etherscan.io']
                        }]
                    });
                    logMessage('✅ Sepolia testnet added to MetaMask!', 'success');
                } else {
                    logMessage('❌ MetaMask not detected', 'error');
                }
            } catch (error) {
                logMessage(`Error adding network: ${error.message}`, 'error');
            }
        }

        async function copyTestAccount() {
            const privateKey = '0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80';
            const indicator = document.getElementById('accountCopyIndicator');
            
            try {
                await navigator.clipboard.writeText(privateKey);
                indicator.className = 'status-indicator success';
                indicator.textContent = '✅ Private key copied to clipboard!';
                logMessage('Test account private key copied to clipboard', 'success');
                
                setTimeout(() => {
                    indicator.textContent = '';
                    indicator.className = '';
                }, 3000);
            } catch (error) {
                indicator.className = 'status-indicator error';
                indicator.textContent = '❌ Failed to copy. Copy manually from above.';
            }
        }
    </script>
</body>
</html> 