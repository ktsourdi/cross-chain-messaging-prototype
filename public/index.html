<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cross-Chain Messaging Prototype</title>
    <script src="https://cdn.jsdelivr.net/npm/web3@1.10.4/dist/web3.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .main-content {
            padding: 40px;
        }

        .status-bar {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 30px;
            border-left: 4px solid #007bff;
        }

        .status-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .status-item:last-child {
            margin-bottom: 0;
        }

        .status-label {
            font-weight: 600;
            color: #495057;
        }

        .status-value {
            color: #007bff;
            font-family: monospace;
        }

        .section {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            border: 1px solid #e9ecef;
        }

        .section h2 {
            color: #2c3e50;
            margin-bottom: 20px;
            font-size: 1.5rem;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #495057;
        }

        .form-group input, .form-group select, .form-group textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.3s;
        }

        .form-group input:focus, .form-group select:focus, .form-group textarea:focus {
            outline: none;
            border-color: #007bff;
        }

        .btn {
            background: linear-gradient(135deg, #007bff 0%, #0056b3 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            margin-right: 10px;
            margin-bottom: 10px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,123,255,0.3);
        }

        .btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
        }

        .btn-success {
            background: linear-gradient(135deg, #28a745 0%, #1e7e34 100%);
        }

        .btn-danger {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
        }

        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
        }

        .log-container {
            background: #1e1e1e;
            color: #00ff00;
            padding: 20px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            max-height: 300px;
            overflow-y: auto;
            margin-top: 20px;
        }

        .log-entry {
            margin-bottom: 5px;
            padding: 5px;
            border-left: 3px solid #00ff00;
            padding-left: 10px;
        }

        .log-error {
            color: #ff6b6b;
            border-left-color: #ff6b6b;
        }

        .log-success {
            color: #51cf66;
            border-left-color: #51cf66;
        }

        .log-info {
            color: #74c0fc;
            border-left-color: #74c0fc;
        }

        .alert {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .alert-warning {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
        }

        .alert-info {
            background: #d1ecf1;
            border: 1px solid #bee5eb;
            color: #0c5460;
        }

        .status-indicator {
            margin-top: 10px;
            padding: 8px;
            border-radius: 4px;
            font-size: 0.9rem;
            text-align: center;
        }

        .status-indicator.success {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }

        .status-indicator.error {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
        }

        .status-indicator.loading {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
        }

        code {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 8px 12px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            display: block;
            margin: 10px 0;
            color: #495057;
        }

        h3 {
            color: #495057;
            font-size: 1.1rem;
            margin-bottom: 10px;
        }

        ul {
            margin: 10px 0;
            padding-left: 20px;
        }

        ul li {
            margin: 5px 0;
            font-size: 0.9rem;
        }

        .message-list {
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 15px;
            background: #f8f9fa;
            max-height: 200px;
            overflow-y: auto;
        }

        .message-item {
            padding: 10px;
            margin: 5px 0;
            border-radius: 6px;
            background: white;
            border-left: 4px solid #007bff;
            font-size: 0.9rem;
        }

        .message-item.pending {
            border-left-color: #ffc107;
        }

        .message-item.success {
            border-left-color: #28a745;
        }

        .message-item.failed {
            border-left-color: #dc3545;
        }

        .chain-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: bold;
            margin: 0 5px;
        }

        .chain-ethereum {
            background: #627eea;
            color: white;
        }

        .chain-polygon {
            background: #8247e5;
            color: white;
        }

        .chain-bsc {
            background: #f3ba2f;
            color: black;
        }

        .chain-arbitrum {
            background: #28a0f0;
            color: white;
        }

        @media (max-width: 768px) {
            .grid {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .main-content {
                padding: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üåâ Cross-Chain Messaging</h1>
            <p>Test and interact with the cross-chain messaging prototype</p>
        </div>

        <div class="main-content">
            <div class="section">
                <h2>üöÄ Quick Setup Guide</h2>
                <div class="alert alert-info">
                    <strong>üìã Complete Setup Process:</strong> Follow these steps to get everything running!
                </div>
                
                <div class="grid">
                    <div>
                        <h3>Step 1: Start Hardhat Node</h3>
                        <p>Run this command in your terminal:</p>
                        <code>npx hardhat node</code>
                        <button class="btn btn-secondary" onclick="checkNodeStatus()">Check Node Status</button>
                        <div id="nodeStatusIndicator" class="status-indicator"></div>
                    </div>
                    
                    <div>
                        <h3>Step 2: Deploy Contracts</h3>
                        <p>Run this command in another terminal:</p>
                        <code>npx hardhat run scripts/deploy.js --network localhost</code>
                        <button class="btn btn-secondary" onclick="tryFetchContractAddresses()">Auto-Detect Addresses</button>
                        <div id="deployStatusIndicator" class="status-indicator"></div>
                    </div>
                </div>
                
                <div class="grid">
                    <div>
                        <h3>Step 3: Connect MetaMask</h3>
                        <p>Add Hardhat network to MetaMask:</p>
                        <ul>
                            <li><strong>Network Name:</strong> Hardhat</li>
                            <li><strong>RPC URL:</strong> http://localhost:8545</li>
                            <li><strong>Chain ID:</strong> 31337</li>
                            <li><strong>Currency:</strong> ETH</li>
                        </ul>
                        <button class="btn" onclick="addHardhatNetwork()">Add Hardhat Network</button>
                        <button class="btn btn-secondary" onclick="addSepoliaNetwork()">Add Sepolia Network</button>
                    </div>
                    
                    <div>
                        <h3>Step 4: Import Test Account</h3>
                        <p>Import Hardhat test account #0:</p>
                        <code>0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80</code>
                        <button class="btn btn-secondary" onclick="copyTestAccount()">Copy Private Key</button>
                        <div id="accountCopyIndicator" class="status-indicator"></div>
                    </div>
                </div>
            </div>

            <div class="status-bar">
                <div class="status-item">
                    <span class="status-label">üîó Hardhat Node:</span>
                    <span class="status-value" id="nodeStatus">Unknown</span>
                </div>
                <div class="status-item">
                    <span class="status-label">üëõ Wallet:</span>
                    <span class="status-value" id="walletStatus">Not Connected</span>
                </div>
                <div class="status-item">
                    <span class="status-label">üåê Network:</span>
                    <span class="status-value" id="networkStatus">Unknown</span>
                </div>
                <div class="status-item">
                    <span class="status-label">üìú Contracts:</span>
                    <span class="status-value" id="contractStatus">Not Loaded</span>
                </div>
            </div>

            <div class="grid">
                <div class="section">
                    <h2>üîß Setup</h2>
                    
                    <div class="form-group">
                        <label for="messengerAddress">CrossChainMessenger Address:</label>
                        <input type="text" id="messengerAddress" placeholder="0x..." />
                    </div>
                    
                    <div class="form-group">
                        <label for="testTargetAddress">TestTarget Address:</label>
                        <input type="text" id="testTargetAddress" placeholder="0x..." />
                    </div>
                    
                    <button class="btn" onclick="connectWallet()">Connect Wallet</button>
                    <button class="btn btn-secondary" onclick="loadContracts()">Load Contracts</button>
                </div>

                <div class="section">
                    <h2>üìä Contract State</h2>
                    
                    <div class="form-group">
                        <label>TestTarget Counter:</label>
                        <input type="text" id="counterValue" readonly />
                    </div>
                    
                    <div class="form-group">
                        <label>Stored Value:</label>
                        <input type="text" id="storedValue" readonly />
                    </div>
                    
                    <button class="btn btn-secondary" onclick="refreshState()">Refresh State</button>
                </div>
            </div>

            <div class="section">
                <h2>üì® Cross-Chain Message Hub</h2>
                
                <div class="alert alert-info">
                    <strong>üåâ Cross-Chain Demo:</strong> This simulates sending messages between different blockchain networks. In production, relayers would process messages across real chains.
                </div>
                
                <div class="grid">
                    <div>
                        <div class="form-group">
                            <label for="sourceChain">Source Chain (Current):</label>
                            <select id="sourceChain">
                                <option value="31337">üè† Hardhat Localhost</option>
                                <option value="1">üî∑ Ethereum Mainnet</option>
                                <option value="137">üü£ Polygon</option>
                                <option value="56">üü° BSC</option>
                                <option value="42161">üîµ Arbitrum</option>
                                <option value="11155111">üß™ Sepolia Testnet</option>
                            </select>
                        </div>
                        
                        <div class="form-group">
                            <label for="targetChain">Target Chain (Destination):</label>
                            <select id="targetChain">
                                <option value="137">üü£ Polygon</option>
                                <option value="31337">üè† Hardhat Localhost</option>
                                <option value="1">üî∑ Ethereum Mainnet</option>
                                <option value="56">üü° BSC</option>
                                <option value="42161">üîµ Arbitrum</option>
                                <option value="11155111">üß™ Sepolia Testnet</option>
                            </select>
                        </div>
                        
                        <div class="form-group">
                            <label for="messageType">Message Type:</label>
                            <select id="messageType" onchange="updateMessageForm()">
                                <option value="setCounter">Set Counter</option>
                                <option value="incrementCounter">Increment Counter</option>
                                <option value="storeValue">Store Value</option>
                                <option value="customCall">Custom Contract Call</option>
                            </select>
                        </div>
                    </div>
                    
                    <div>
                        <div class="form-group" id="valueInput">
                            <label for="messageValue">Value:</label>
                            <input type="number" id="messageValue" placeholder="Enter value" />
                        </div>
                        
                        <div class="form-group" id="customCallInput" style="display: none;">
                            <label for="customCallData">Custom Call Data:</label>
                            <input type="text" id="customCallData" placeholder="0x..." />
                        </div>
                        
                        <div class="form-group">
                            <label for="gasLimit">Gas Limit:</label>
                            <input type="number" id="gasLimit" value="200000" />
                        </div>
                        
                        <div class="form-group">
                            <label>Estimated Cost:</label>
                            <input type="text" id="estimatedCost" readonly placeholder="~$0.50" />
                        </div>
                    </div>
                </div>
                
                <div class="grid">
                    <button class="btn btn-success" onclick="sendCrossChainMessage()">üöÄ Send Cross-Chain Message</button>
                    <button class="btn btn-secondary" onclick="simulateFullWorkflow()">üé≠ Simulate Full Workflow</button>
                    <button class="btn" onclick="sendLocalMessage()">üìç Send Local Message</button>
                </div>
            </div>

            <div class="section">
                <h2>üîÑ Cross-Chain Message Status</h2>
                
                <div class="grid">
                    <div>
                        <h3>üì§ Outgoing Messages</h3>
                        <div id="outgoingMessages" class="message-list">
                            <div class="message-item">No messages sent yet</div>
                        </div>
                    </div>
                    
                    <div>
                        <h3>üì• Incoming Messages</h3>
                        <div id="incomingMessages" class="message-list">
                            <div class="message-item">No messages received yet</div>
                        </div>
                    </div>
                </div>
                
                <button class="btn btn-secondary" onclick="refreshMessageStatus()">üîÑ Refresh Status</button>
            </div>

            <div class="section">
                <h2>üîê Admin Functions</h2>
                
                <div class="grid">
                    <div>
                        <div class="form-group">
                            <label for="relayerAddress">Relayer Address:</label>
                            <input type="text" id="relayerAddress" placeholder="0x..." />
                        </div>
                        
                        <button class="btn" onclick="addRelayer()">Add Relayer</button>
                        <button class="btn btn-danger" onclick="removeRelayer()">Remove Relayer</button>
                    </div>
                    
                    <div>
                        <div class="form-group">
                            <label for="chainId">Chain ID:</label>
                            <input type="number" id="chainId" placeholder="1, 137, 56..." />
                        </div>
                        
                        <button class="btn" onclick="enableChain()">Enable Chain</button>
                        <button class="btn btn-danger" onclick="disableChain()">Disable Chain</button>
                    </div>
                </div>
            </div>

            <div class="section">
                <h2>üìã Activity Log</h2>
                <button class="btn btn-secondary" onclick="clearLog()">Clear Log</button>
                <div class="log-container" id="logContainer">
                    <div class="log-entry log-info">Welcome to Cross-Chain Messaging Interface</div>
                    <div class="log-entry log-info">Connect your wallet and load contracts to get started</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let web3;
        let account;
        let messengerContract;
        let testTargetContract;

        const MESSENGER_ABI = [
            {
                "inputs": [],
                "name": "addRelayer",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [{"internalType": "address","name": "relayer","type": "address"}],
                "name": "addRelayer",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [{"internalType": "uint256","name": "chainId","type": "uint256"}],
                "name": "enableChain",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [{"internalType": "uint256","name": "chainId","type": "uint256"}],
                "name": "disableChain",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [{"internalType": "address","name": "relayer","type": "address"}],
                "name": "removeRelayer",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {"internalType": "uint256","name": "targetChain","type": "uint256"},
                    {"internalType": "address","name": "targetContract","type": "address"},
                    {"internalType": "bytes","name": "payload","type": "bytes"},
                    {"internalType": "uint256","name": "gasLimit","type": "uint256"}
                ],
                "name": "sendMessage",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {"internalType": "bytes32","name": "messageId","type": "bytes32"},
                    {"internalType": "uint256","name": "sourceChain","type": "uint256"},
                    {"internalType": "address","name": "sender","type": "address"},
                    {"internalType": "address","name": "targetContract","type": "address"},
                    {"internalType": "bytes","name": "payload","type": "bytes"},
                    {"internalType": "uint256","name": "nonce","type": "uint256"},
                    {"internalType": "uint256","name": "gasLimit","type": "uint256"},
                    {"internalType": "uint256","name": "expiry","type": "uint256"},
                    {"internalType": "bytes","name": "signature","type": "bytes"}
                ],
                "name": "processMessage",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [{"internalType": "uint256","name": "chainId","type": "uint256"}],
                "name": "getNextNonce",
                "outputs": [{"internalType": "uint256","name": "","type": "uint256"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "anonymous": false,
                "inputs": [
                    {"indexed": true,"internalType": "bytes32","name": "messageId","type": "bytes32"},
                    {"indexed": true,"internalType": "uint256","name": "targetChain","type": "uint256"},
                    {"indexed": true,"internalType": "address","name": "sender","type": "address"},
                    {"indexed": false,"internalType": "address","name": "targetContract","type": "address"},
                    {"indexed": false,"internalType": "bytes","name": "payload","type": "bytes"},
                    {"indexed": false,"internalType": "uint256","name": "nonce","type": "uint256"},
                    {"indexed": false,"internalType": "uint256","name": "gasLimit","type": "uint256"}
                ],
                "name": "MessageSent",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {"indexed": true,"internalType": "bytes32","name": "messageId","type": "bytes32"},
                    {"indexed": true,"internalType": "uint256","name": "sourceChain","type": "uint256"},
                    {"indexed": true,"internalType": "address","name": "sender","type": "address"},
                    {"indexed": false,"internalType": "address","name": "targetContract","type": "address"},
                    {"indexed": false,"internalType": "bool","name": "success","type": "bool"}
                ],
                "name": "MessageProcessed",
                "type": "event"
            }
        ];

        const TEST_TARGET_ABI = [
            {
                "inputs": [{"internalType": "uint256","name": "_counter","type": "uint256"}],
                "name": "setCounter",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "incrementCounter",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [{"internalType": "uint256","name": "_value","type": "uint256"}],
                "name": "storeValue",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "counter",
                "outputs": [{"internalType": "uint256","name": "","type": "uint256"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "storedValue",
                "outputs": [{"internalType": "uint256","name": "","type": "uint256"}],
                "stateMutability": "view",
                "type": "function"
            }
        ];

        async function connectWallet() {
            try {
                if (typeof window.ethereum !== 'undefined') {
                    web3 = new Web3(window.ethereum);
                    const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                    account = accounts[0];
                    
                    const networkId = await web3.eth.net.getId();
                    
                                    document.getElementById('walletStatus').textContent = `${account.substring(0, 6)}...${account.substring(38)}`;
                document.getElementById('walletStatus').style.color = '#28a745';
                document.getElementById('networkStatus').textContent = `Chain ID: ${networkId}`;
                
                if (networkId == 31337) {
                    document.getElementById('networkStatus').style.color = '#28a745';
                } else {
                    document.getElementById('networkStatus').style.color = '#ffc107';
                }
                
                logMessage('Wallet connected successfully', 'success');
                } else {
                    logMessage('MetaMask not detected. Please install MetaMask.', 'error');
                }
            } catch (error) {
                logMessage(`Error connecting wallet: ${error.message}`, 'error');
            }
        }

        async function loadContracts() {
            try {
                const messengerAddress = document.getElementById('messengerAddress').value;
                const testTargetAddress = document.getElementById('testTargetAddress').value;
                
                if (!messengerAddress || !testTargetAddress) {
                    logMessage('Please enter both contract addresses', 'error');
                    return;
                }
                
                messengerContract = new web3.eth.Contract(MESSENGER_ABI, messengerAddress);
                testTargetContract = new web3.eth.Contract(TEST_TARGET_ABI, testTargetAddress);
                
                document.getElementById('contractStatus').textContent = 'Loaded';
                document.getElementById('contractStatus').style.color = '#28a745';
                
                logMessage('Contracts loaded successfully', 'success');
                await refreshState();
            } catch (error) {
                logMessage(`Error loading contracts: ${error.message}`, 'error');
            }
        }

        async function refreshState() {
            try {
                if (!testTargetContract) {
                    logMessage('Please load contracts first', 'error');
                    return;
                }
                
                // Check if contract is deployed at the address
                const code = await web3.eth.getCode(testTargetContract.options.address);
                if (code === '0x') {
                    logMessage('TestTarget contract not deployed at the specified address', 'error');
                    return;
                }
                
                logMessage('Calling counter() method...', 'info');
                const counter = await testTargetContract.methods.counter().call();
                logMessage(`Counter value: ${counter}`, 'info');
                
                logMessage('Calling storedValue() method...', 'info');
                const storedValue = await testTargetContract.methods.storedValue().call();
                logMessage(`Stored value: ${storedValue}`, 'info');
                
                document.getElementById('counterValue').value = counter;
                document.getElementById('storedValue').value = storedValue;
                
                logMessage('Contract state refreshed successfully', 'success');
            } catch (error) {
                logMessage(`Error refreshing state: ${error.message}`, 'error');
                logMessage(`Contract address: ${testTargetContract?.options?.address}`, 'error');
                logMessage('Please check if the TestTarget contract is deployed correctly', 'error');
            }
        }

        function updateMessageForm() {
            const messageType = document.getElementById('messageType').value;
            const valueInput = document.getElementById('valueInput');
            const customCallInput = document.getElementById('customCallInput');
            
            if (messageType === 'incrementCounter') {
                valueInput.style.display = 'none';
                customCallInput.style.display = 'none';
            } else if (messageType === 'customCall') {
                valueInput.style.display = 'none';
                customCallInput.style.display = 'block';
            } else {
                valueInput.style.display = 'block';
                customCallInput.style.display = 'none';
            }
            
            updateEstimatedCost();
        }
        
        function updateEstimatedCost() {
            const sourceChain = document.getElementById('sourceChain').value;
            const targetChain = document.getElementById('targetChain').value;
            const gasLimit = document.getElementById('gasLimit').value;
            
            // Simulate cost calculation
            const gasCosts = {
                '1': 50,    // Ethereum - expensive
                '137': 0.1, // Polygon - cheap
                '56': 1,    // BSC - medium
                '42161': 2, // Arbitrum - low
                '31337': 0, // Hardhat - free
                '11155111': 5 // Sepolia - testnet
            };
            
            const sourceCost = (gasCosts[sourceChain] || 1) * (gasLimit / 21000);
            const targetCost = (gasCosts[targetChain] || 1) * (gasLimit / 21000);
            const relayerFee = 0.1; // Fixed relayer fee
            
            const totalCost = sourceCost + targetCost + relayerFee;
            document.getElementById('estimatedCost').value = `~$${totalCost.toFixed(2)}`;
        }
        
        // Global message tracking
        let messageCounter = 0;
        let pendingMessages = [];

        async function sendMessage() {
            try {
                if (!testTargetContract || !account) {
                    logMessage('Please connect wallet and load contracts first', 'error');
                    return;
                }
                
                // Check account balance
                const balance = await web3.eth.getBalance(account);
                const balanceEth = web3.utils.fromWei(balance, 'ether');
                logMessage(`Account balance: ${balanceEth} ETH`, 'info');
                
                if (parseFloat(balanceEth) < 0.01) {
                    logMessage('Warning: Low ETH balance. Make sure you have enough ETH for gas', 'error');
                }
                
                const targetChain = document.getElementById('targetChain').value;
                const messageType = document.getElementById('messageType').value;
                const messageValue = document.getElementById('messageValue').value;
                
                logMessage(`Executing ${messageType} directly on TestTarget contract...`, 'info');
                logMessage(`Contract address: ${testTargetContract.options.address}`, 'info');
                logMessage(`From account: ${account}`, 'info');
                
                let tx;
                
                try {
                    if (messageType === 'setCounter') {
                        if (!messageValue) {
                            logMessage('Please enter a value for setCounter', 'error');
                            return;
                        }
                        logMessage(`Calling setCounter(${messageValue})...`, 'info');
                        
                        // First test the call to make sure it works
                        logMessage('Testing setCounter call...', 'info');
                        await testTargetContract.methods.setCounter(messageValue).call({ from: account });
                        logMessage('Call test successful, sending transaction...', 'info');
                        
                        tx = await testTargetContract.methods.setCounter(messageValue).send({ 
                            from: account,
                            gas: 200000  // Fixed gas limit that works
                        });
                    } else if (messageType === 'incrementCounter') {
                        logMessage('Calling incrementCounter()...', 'info');
                        
                        logMessage('Testing incrementCounter call...', 'info');
                        await testTargetContract.methods.incrementCounter().call({ from: account });
                        logMessage('Call test successful, sending transaction...', 'info');
                        
                        tx = await testTargetContract.methods.incrementCounter().send({ 
                            from: account,
                            gas: 200000
                        });
                    } else if (messageType === 'storeValue') {
                        if (!messageValue) {
                            logMessage('Please enter a value for storeValue', 'error');
                            return;
                        }
                        logMessage(`Calling storeValue(${messageValue})...`, 'info');
                        
                        logMessage('Testing storeValue call...', 'info');
                        await testTargetContract.methods.storeValue(messageValue).call({ from: account });
                        logMessage('Call test successful, sending transaction...', 'info');
                        
                        tx = await testTargetContract.methods.storeValue(messageValue).send({ 
                            from: account,
                            gas: 200000
                        });
                    }
                    
                    logMessage(`Transaction successful! Hash: ${tx.transactionHash}`, 'success');
                    logMessage('Refreshing contract state...', 'info');
                    
                    // Auto-refresh state after successful transaction
                    setTimeout(async () => {
                        await refreshState();
                    }, 1000);
                    
                } catch (contractError) {
                    logMessage(`Contract call failed: ${contractError.message}`, 'error');
                    console.error('Contract error details:', contractError);
                    
                    // Try to get more specific error info
                    if (contractError.message.includes('revert')) {
                        logMessage('Transaction was reverted by the contract', 'error');
                    } else if (contractError.message.includes('gas')) {
                        logMessage('Gas-related error - try increasing gas limit', 'error');
                    } else if (contractError.message.includes('nonce')) {
                        logMessage('Nonce error - try refreshing and resending', 'error');
                    }
                }
                
            } catch (error) {
                logMessage(`Error executing message: ${error.message}`, 'error');
                logMessage('Check console for detailed error information', 'info');
                console.error('Detailed error:', error);
            }
        }

        async function simulateRelayerProcessing() {
            logMessage('Simulating relayer processing...', 'info');
            logMessage('In a real implementation, relayers would:', 'info');
            logMessage('1. Listen for MessageSent events', 'info');
            logMessage('2. Create and sign message proofs', 'info');
            logMessage('3. Call processMessage on target chain', 'info');
            logMessage('4. Handle gas estimation and retry logic', 'info');
            logMessage('Note: This demo runs on a single chain for simplicity', 'info');
        }

        async function addRelayer() {
            try {
                const relayerAddress = document.getElementById('relayerAddress').value;
                if (!relayerAddress) {
                    logMessage('Please enter relayer address', 'error');
                    return;
                }
                
                const tx = await messengerContract.methods.addRelayer(relayerAddress).send({ from: account });
                logMessage(`Relayer added! Transaction: ${tx.transactionHash}`, 'success');
            } catch (error) {
                logMessage(`Error adding relayer: ${error.message}`, 'error');
            }
        }

        async function removeRelayer() {
            try {
                const relayerAddress = document.getElementById('relayerAddress').value;
                if (!relayerAddress) {
                    logMessage('Please enter relayer address', 'error');
                    return;
                }
                
                const tx = await messengerContract.methods.removeRelayer(relayerAddress).send({ from: account });
                logMessage(`Relayer removed! Transaction: ${tx.transactionHash}`, 'success');
            } catch (error) {
                logMessage(`Error removing relayer: ${error.message}`, 'error');
            }
        }

        async function enableChain() {
            try {
                const chainId = document.getElementById('chainId').value;
                if (!chainId) {
                    logMessage('Please enter chain ID', 'error');
                    return;
                }
                
                const tx = await messengerContract.methods.enableChain(chainId).send({ from: account });
                logMessage(`Chain ${chainId} enabled! Transaction: ${tx.transactionHash}`, 'success');
            } catch (error) {
                logMessage(`Error enabling chain: ${error.message}`, 'error');
            }
        }

        async function disableChain() {
            try {
                const chainId = document.getElementById('chainId').value;
                if (!chainId) {
                    logMessage('Please enter chain ID', 'error');
                    return;
                }
                
                const tx = await messengerContract.methods.disableChain(chainId).send({ from: account });
                logMessage(`Chain ${chainId} disabled! Transaction: ${tx.transactionHash}`, 'success');
            } catch (error) {
                logMessage(`Error disabling chain: ${error.message}`, 'error');
            }
        }

        function logMessage(message, type = 'info') {
            const logContainer = document.getElementById('logContainer');
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry log-${type}`;
            logEntry.textContent = `[${timestamp}] ${message}`;
            logContainer.appendChild(logEntry);
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        function clearLog() {
            document.getElementById('logContainer').innerHTML = '';
            logMessage('Log cleared', 'info');
        }

        // Initialize form
        updateMessageForm();
        
        // Add event listeners for cost updates
        document.getElementById('sourceChain').addEventListener('change', updateEstimatedCost);
        document.getElementById('targetChain').addEventListener('change', updateEstimatedCost);
        document.getElementById('gasLimit').addEventListener('input', updateEstimatedCost);
        
        // New cross-chain functions
        async function sendCrossChainMessage() {
            try {
                const sourceChain = document.getElementById('sourceChain').value;
                const targetChain = document.getElementById('targetChain').value;
                const messageType = document.getElementById('messageType').value;
                const messageValue = document.getElementById('messageValue').value;
                
                if (sourceChain === targetChain) {
                    logMessage('‚ö†Ô∏è Source and target chains cannot be the same for cross-chain messaging', 'error');
                    return;
                }
                
                const messageId = ++messageCounter;
                const message = {
                    id: messageId,
                    sourceChain: getChainName(sourceChain),
                    targetChain: getChainName(targetChain),
                    type: messageType,
                    value: messageValue,
                    status: 'pending',
                    timestamp: new Date().toLocaleTimeString()
                };
                
                addOutgoingMessage(message);
                logMessage(`üöÄ Cross-chain message initiated: ${sourceChain} ‚Üí ${targetChain}`, 'success');
                logMessage(`üìã Message Type: ${messageType}, Value: ${messageValue}`, 'info');
                
                // Simulate cross-chain processing
                simulateMessageProcessing(message);
                
            } catch (error) {
                logMessage(`‚ùå Error sending cross-chain message: ${error.message}`, 'error');
            }
        }
        
        async function sendLocalMessage() {
            // Use the existing sendMessage function for local testing
            await sendMessage();
        }
        
        async function simulateFullWorkflow() {
            logMessage('üé≠ Starting full cross-chain workflow simulation...', 'info');
            
            const steps = [
                '1Ô∏è‚É£ Creating cross-chain message...',
                '2Ô∏è‚É£ Signing message with relayer key...',
                '3Ô∏è‚É£ Broadcasting to source chain...',
                '4Ô∏è‚É£ Waiting for block confirmation...',
                '5Ô∏è‚É£ Relayer detecting message event...',
                '6Ô∏è‚É£ Generating merkle proof...',
                '7Ô∏è‚É£ Submitting to target chain...',
                '8Ô∏è‚É£ Target chain verification...',
                '9Ô∏è‚É£ Executing message on target...',
                '‚úÖ Cross-chain message completed!'
            ];
            
            for (let i = 0; i < steps.length; i++) {
                setTimeout(() => {
                    logMessage(steps[i], 'info');
                }, i * 800);
            }
            
            // Simulate adding a completed message
            setTimeout(() => {
                const message = {
                    id: ++messageCounter,
                    sourceChain: 'Ethereum',
                    targetChain: 'Polygon',
                    type: 'setCounter',
                    value: '42',
                    status: 'success',
                    timestamp: new Date().toLocaleTimeString()
                };
                addIncomingMessage(message);
            }, 8000);
        }
        
        function simulateMessageProcessing(message) {
            // Simulate processing delay
            setTimeout(() => {
                message.status = 'relaying';
                updateMessageStatus(message);
                logMessage(`üîÑ Message ${message.id} being processed by relayers...`, 'info');
            }, 2000);
            
            setTimeout(() => {
                message.status = 'success';
                updateMessageStatus(message);
                addIncomingMessage(message);
                logMessage(`‚úÖ Message ${message.id} successfully delivered to ${message.targetChain}!`, 'success');
            }, 5000);
        }
        
        function addOutgoingMessage(message) {
            const container = document.getElementById('outgoingMessages');
            if (container.children[0]?.textContent === 'No messages sent yet') {
                container.innerHTML = '';
            }
            
            const messageElement = createMessageElement(message);
            container.appendChild(messageElement);
        }
        
        function addIncomingMessage(message) {
            const container = document.getElementById('incomingMessages');
            if (container.children[0]?.textContent === 'No messages received yet') {
                container.innerHTML = '';
            }
            
            const messageElement = createMessageElement(message);
            container.appendChild(messageElement);
        }
        
        function createMessageElement(message) {
            const div = document.createElement('div');
            div.className = `message-item ${message.status}`;
            div.id = `message-${message.id}`;
            div.innerHTML = `
                <div><strong>Message #${message.id}</strong> - ${message.type}</div>
                <div>
                    <span class="chain-badge">${message.sourceChain}</span> ‚Üí 
                    <span class="chain-badge">${message.targetChain}</span>
                </div>
                <div>Value: ${message.value} | Status: ${message.status} | ${message.timestamp}</div>
            `;
            return div;
        }
        
        function updateMessageStatus(message) {
            const element = document.getElementById(`message-${message.id}`);
            if (element) {
                element.className = `message-item ${message.status}`;
                element.querySelector('div:last-child').textContent = 
                    `Value: ${message.value} | Status: ${message.status} | ${message.timestamp}`;
            }
        }
        
        function getChainName(chainId) {
            const names = {
                '1': 'Ethereum',
                '137': 'Polygon', 
                '56': 'BSC',
                '42161': 'Arbitrum',
                '31337': 'Hardhat',
                '11155111': 'Sepolia'
            };
            return names[chainId] || `Chain ${chainId}`;
        }
        
        function refreshMessageStatus() {
            logMessage('üîÑ Refreshing message status...', 'info');
            // In a real app, this would query the blockchain for message states
            logMessage('‚úÖ Message status refreshed', 'success');
        }

        // Auto-check node status on page load
        checkNodeStatus();

        // Helper functions for automation
        async function checkNodeStatus() {
            const indicator = document.getElementById('nodeStatusIndicator');
            const statusElement = document.getElementById('nodeStatus');
            
            try {
                indicator.className = 'status-indicator loading';
                indicator.textContent = 'Checking...';
                
                let rpcUrl = 'http://localhost:8545';
                let expectedChainId = '0x7a69'; // 31337 in hex for Hardhat
                let networkName = 'Hardhat node';
                
                // Check if we're on a testnet via MetaMask
                if (typeof window.ethereum !== 'undefined') {
                    try {
                        const chainId = await window.ethereum.request({ method: 'eth_chainId' });
                        if (chainId === '0xaa36a7') { // 11155111 in hex for Sepolia
                            rpcUrl = 'https://ethereum-sepolia-rpc.publicnode.com';
                            expectedChainId = '0xaa36a7';
                            networkName = 'Sepolia testnet';
                        }
                    } catch (e) {
                        // Fall back to Hardhat check
                    }
                }
                
                const response = await fetch(rpcUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        jsonrpc: '2.0',
                        method: 'eth_chainId',
                        params: [],
                        id: 1
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.result === expectedChainId) {
                        indicator.className = 'status-indicator success';
                        indicator.textContent = `‚úÖ Connected to ${networkName}!`;
                        statusElement.textContent = 'Connected';
                        statusElement.style.color = '#28a745';
                        
                        // Auto-try to fetch contract addresses
                        setTimeout(() => tryFetchContractAddresses(), 1000);
                    } else {
                        throw new Error('Wrong network');
                    }
                } else {
                    throw new Error('Connection failed');
                }
            } catch (error) {
                indicator.className = 'status-indicator error';
                indicator.textContent = '‚ùå Network not available. Connect MetaMask or run: npx hardhat node';
                statusElement.textContent = 'Not Connected';
                statusElement.style.color = '#dc3545';
            }
        }

        async function tryFetchContractAddresses() {
            const indicator = document.getElementById('deployStatusIndicator');
            
            try {
                indicator.className = 'status-indicator loading';
                indicator.textContent = 'Checking for deployed contracts...';
                
                // Initialize Web3 connection
                let rpcUrl = 'http://localhost:8545';
                
                // Check if we're on a testnet via MetaMask
                if (typeof window.ethereum !== 'undefined') {
                    try {
                        const chainId = await window.ethereum.request({ method: 'eth_chainId' });
                        if (chainId === '0xaa36a7') { // 11155111 in hex for Sepolia
                            rpcUrl = 'https://ethereum-sepolia-rpc.publicnode.com';
                        }
                    } catch (e) {
                        // Fall back to Hardhat
                    }
                }
                
                const tempWeb3 = new Web3(rpcUrl);
                
                // Known contract addresses by network
                const KNOWN_ADDRESSES = {
                    31337: { // Hardhat Local
                        crossChainMessenger: '0x5FbDB2315678afecb367f032d93F642f64180aa3',
                        testTarget: '0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512'
                    },
                    11155111: { // Sepolia Testnet
                        crossChainMessenger: '0x3014b38b18ea56F34958702FbAC629594208CEFC',
                        testTarget: '0x22e3675dD5514A7659066Bc11DfE48c3A97B0B7B'
                    }
                };
                
                // Get current network
                const chainId = await tempWeb3.eth.getChainId();
                const knownAddresses = KNOWN_ADDRESSES[chainId];
                
                if (knownAddresses) {
                    // Use known addresses for this network
                    document.getElementById('messengerAddress').value = knownAddresses.crossChainMessenger;
                    document.getElementById('testTargetAddress').value = knownAddresses.testTarget;
                    
                    indicator.className = 'status-indicator success';
                    indicator.textContent = `‚úÖ Contract addresses loaded for ${getChainName(chainId.toString())}!`;
                    
                    logMessage(`Loaded contract addresses for ${getChainName(chainId.toString())}!`, 'success');
                    logMessage(`CrossChainMessenger: ${knownAddresses.crossChainMessenger}`, 'info');
                    logMessage(`TestTarget: ${knownAddresses.testTarget}`, 'info');
                    
                    // Auto-load contracts
                    setTimeout(() => loadContracts(), 1000);
                    return;
                }
                
                // Fallback: Common deployment addresses (Hardhat deploys to these usually)
                const commonAddresses = [
                    '0x5FbDB2315678afecb367f032d93F642f64180aa3',
                    '0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512',
                    '0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0',
                    '0xCf7Ed3AccA5a467e9e704C703E8D87F634fB0Fc9'
                ];
                
                let messengerAddr = null;
                let testTargetAddr = null;
                
                // Check each address to see what's deployed
                for (const addr of commonAddresses) {
                    try {
                        const code = await tempWeb3.eth.getCode(addr);
                        if (code !== '0x') {
                            // Try to determine which contract this is
                            const contract = new tempWeb3.eth.Contract(TEST_TARGET_ABI, addr);
                            try {
                                await contract.methods.counter().call();
                                testTargetAddr = addr;
                                logMessage(`Found TestTarget at: ${addr}`, 'success');
                            } catch {
                                // Probably the messenger contract
                                messengerAddr = addr;
                                logMessage(`Found CrossChainMessenger at: ${addr}`, 'success');
                            }
                        }
                    } catch (e) {
                        // Continue checking other addresses
                    }
                }
                
                if (messengerAddr && testTargetAddr) {
                    document.getElementById('messengerAddress').value = messengerAddr;
                    document.getElementById('testTargetAddress').value = testTargetAddr;
                    
                    indicator.className = 'status-indicator success';
                    indicator.textContent = '‚úÖ Contract addresses auto-detected!';
                    
                    logMessage('Contract addresses auto-populated!', 'success');
                    logMessage(`CrossChainMessenger: ${messengerAddr}`, 'info');
                    logMessage(`TestTarget: ${testTargetAddr}`, 'info');
                    
                    // Auto-load contracts
                    setTimeout(() => loadContracts(), 1000);
                    
                } else {
                    indicator.className = 'status-indicator error';
                    indicator.textContent = '‚ùå Contracts not found. Please deploy them first.';
                }
                
            } catch (error) {
                indicator.className = 'status-indicator error';
                indicator.textContent = '‚ùå Error checking contracts: ' + error.message;
            }
        }

        async function addHardhatNetwork() {
            try {
                if (typeof window.ethereum !== 'undefined') {
                    await window.ethereum.request({
                        method: 'wallet_addEthereumChain',
                        params: [{
                            chainId: '0x7a69', // 31337 in hex
                            chainName: 'Hardhat Local',
                            nativeCurrency: {
                                name: 'Ethereum',
                                symbol: 'ETH',
                                decimals: 18
                            },
                            rpcUrls: ['http://localhost:8545'],
                            blockExplorerUrls: null
                        }]
                    });
                    logMessage('‚úÖ Hardhat network added to MetaMask!', 'success');
                } else {
                    logMessage('‚ùå MetaMask not detected', 'error');
                }
            } catch (error) {
                logMessage(`Error adding network: ${error.message}`, 'error');
            }
        }

        async function addSepoliaNetwork() {
            try {
                if (typeof window.ethereum !== 'undefined') {
                    await window.ethereum.request({
                        method: 'wallet_addEthereumChain',
                        params: [{
                            chainId: '0xaa36a7', // 11155111 in hex
                            chainName: 'Sepolia Testnet',
                            nativeCurrency: {
                                name: 'Ethereum',
                                symbol: 'ETH',
                                decimals: 18
                            },
                            rpcUrls: ['https://ethereum-sepolia-rpc.publicnode.com'],
                            blockExplorerUrls: ['https://sepolia.etherscan.io']
                        }]
                    });
                    logMessage('‚úÖ Sepolia testnet added to MetaMask!', 'success');
                } else {
                    logMessage('‚ùå MetaMask not detected', 'error');
                }
            } catch (error) {
                logMessage(`Error adding network: ${error.message}`, 'error');
            }
        }

        async function copyTestAccount() {
            const privateKey = '0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80';
            const indicator = document.getElementById('accountCopyIndicator');
            
            try {
                await navigator.clipboard.writeText(privateKey);
                indicator.className = 'status-indicator success';
                indicator.textContent = '‚úÖ Private key copied to clipboard!';
                logMessage('Test account private key copied to clipboard', 'success');
                
                setTimeout(() => {
                    indicator.textContent = '';
                    indicator.className = '';
                }, 3000);
            } catch (error) {
                indicator.className = 'status-indicator error';
                indicator.textContent = '‚ùå Failed to copy. Copy manually from above.';
            }
        }
    </script>
</body>
</html> 