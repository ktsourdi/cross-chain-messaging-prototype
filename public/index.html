<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cross-Chain Messaging Prototype</title>
    <script src="https://cdn.jsdelivr.net/npm/web3@1.10.4/dist/web3.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .main-content {
            padding: 40px;
        }

        .status-bar {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 30px;
            border-left: 4px solid #007bff;
        }

        .status-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .status-item:last-child {
            margin-bottom: 0;
        }

        .status-label {
            font-weight: 600;
            color: #495057;
        }

        .status-value {
            color: #007bff;
            font-family: monospace;
        }

        .section {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            border: 1px solid #e9ecef;
        }

        .section h2 {
            color: #2c3e50;
            margin-bottom: 20px;
            font-size: 1.5rem;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #495057;
        }

        .form-group input, .form-group select, .form-group textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.3s;
        }

        .form-group input:focus, .form-group select:focus, .form-group textarea:focus {
            outline: none;
            border-color: #007bff;
        }

        .btn {
            background: linear-gradient(135deg, #007bff 0%, #0056b3 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            margin-right: 10px;
            margin-bottom: 10px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,123,255,0.3);
        }

        .btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
        }

        .btn-success {
            background: linear-gradient(135deg, #28a745 0%, #1e7e34 100%);
        }

        .btn-danger {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
        }

        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
        }

        .log-container {
            background: #1e1e1e;
            color: #00ff00;
            padding: 20px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            max-height: 300px;
            overflow-y: auto;
            margin-top: 20px;
        }

        .log-entry {
            margin-bottom: 5px;
            padding: 5px;
            border-left: 3px solid #00ff00;
            padding-left: 10px;
        }

        .log-error {
            color: #ff6b6b;
            border-left-color: #ff6b6b;
        }

        .log-success {
            color: #51cf66;
            border-left-color: #51cf66;
        }

        .log-info {
            color: #74c0fc;
            border-left-color: #74c0fc;
        }

        .alert {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .alert-warning {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
        }

        .alert-info {
            background: #d1ecf1;
            border: 1px solid #bee5eb;
            color: #0c5460;
        }

        .status-indicator {
            margin-top: 10px;
            padding: 8px;
            border-radius: 4px;
            font-size: 0.9rem;
            text-align: center;
        }

        .status-indicator.success {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }

        .status-indicator.error {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
        }

        .status-indicator.loading {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
        }

        code {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 8px 12px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            display: block;
            margin: 10px 0;
            color: #495057;
        }

        h3 {
            color: #495057;
            font-size: 1.1rem;
            margin-bottom: 10px;
        }

        ul {
            margin: 10px 0;
            padding-left: 20px;
        }

        ul li {
            margin: 5px 0;
            font-size: 0.9rem;
        }

        @media (max-width: 768px) {
            .grid {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .main-content {
                padding: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üåâ Cross-Chain Messaging</h1>
            <p>Test and interact with the cross-chain messaging prototype</p>
        </div>

        <div class="main-content">
            <div class="section">
                <h2>üöÄ Quick Setup Guide</h2>
                <div class="alert alert-info">
                    <strong>üìã Complete Setup Process:</strong> Follow these steps to get everything running!
                </div>
                
                <div class="grid">
                    <div>
                        <h3>Step 1: Start Hardhat Node</h3>
                        <p>Run this command in your terminal:</p>
                        <code>npx hardhat node</code>
                        <button class="btn btn-secondary" onclick="checkNodeStatus()">Check Node Status</button>
                        <div id="nodeStatusIndicator" class="status-indicator"></div>
                    </div>
                    
                    <div>
                        <h3>Step 2: Deploy Contracts</h3>
                        <p>Run this command in another terminal:</p>
                        <code>npx hardhat run scripts/deploy.js --network localhost</code>
                        <button class="btn btn-secondary" onclick="tryFetchContractAddresses()">Auto-Detect Addresses</button>
                        <div id="deployStatusIndicator" class="status-indicator"></div>
                    </div>
                </div>
                
                <div class="grid">
                    <div>
                        <h3>Step 3: Connect MetaMask</h3>
                        <p>Add Hardhat network to MetaMask:</p>
                        <ul>
                            <li><strong>Network Name:</strong> Hardhat</li>
                            <li><strong>RPC URL:</strong> http://localhost:8545</li>
                            <li><strong>Chain ID:</strong> 31337</li>
                            <li><strong>Currency:</strong> ETH</li>
                        </ul>
                        <button class="btn" onclick="addHardhatNetwork()">Add Hardhat Network</button>
                    </div>
                    
                    <div>
                        <h3>Step 4: Import Test Account</h3>
                        <p>Import Hardhat test account #0:</p>
                        <code>0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80</code>
                        <button class="btn btn-secondary" onclick="copyTestAccount()">Copy Private Key</button>
                        <div id="accountCopyIndicator" class="status-indicator"></div>
                    </div>
                </div>
            </div>

            <div class="status-bar">
                <div class="status-item">
                    <span class="status-label">üîó Hardhat Node:</span>
                    <span class="status-value" id="nodeStatus">Unknown</span>
                </div>
                <div class="status-item">
                    <span class="status-label">üëõ Wallet:</span>
                    <span class="status-value" id="walletStatus">Not Connected</span>
                </div>
                <div class="status-item">
                    <span class="status-label">üåê Network:</span>
                    <span class="status-value" id="networkStatus">Unknown</span>
                </div>
                <div class="status-item">
                    <span class="status-label">üìú Contracts:</span>
                    <span class="status-value" id="contractStatus">Not Loaded</span>
                </div>
            </div>

            <div class="grid">
                <div class="section">
                    <h2>üîß Setup</h2>
                    
                    <div class="form-group">
                        <label for="messengerAddress">CrossChainMessenger Address:</label>
                        <input type="text" id="messengerAddress" placeholder="0x..." />
                    </div>
                    
                    <div class="form-group">
                        <label for="testTargetAddress">TestTarget Address:</label>
                        <input type="text" id="testTargetAddress" placeholder="0x..." />
                    </div>
                    
                    <button class="btn" onclick="connectWallet()">Connect Wallet</button>
                    <button class="btn btn-secondary" onclick="loadContracts()">Load Contracts</button>
                </div>

                <div class="section">
                    <h2>üìä Contract State</h2>
                    
                    <div class="form-group">
                        <label>TestTarget Counter:</label>
                        <input type="text" id="counterValue" readonly />
                    </div>
                    
                    <div class="form-group">
                        <label>Stored Value:</label>
                        <input type="text" id="storedValue" readonly />
                    </div>
                    
                    <button class="btn btn-secondary" onclick="refreshState()">Refresh State</button>
                </div>
            </div>

            <div class="section">
                <h2>üì® Send Cross-Chain Message</h2>
                
                <div class="grid">
                    <div>
                        <div class="form-group">
                            <label for="targetChain">Target Chain ID:</label>
                            <select id="targetChain">
                                <option value="31337">Hardhat Localhost</option>
                                <option value="1">Ethereum Mainnet</option>
                                <option value="137">Polygon</option>
                                <option value="56">BSC</option>
                                <option value="42161">Arbitrum</option>
                                <option value="11155111">Sepolia Testnet</option>
                            </select>
                        </div>
                        
                        <div class="form-group">
                            <label for="messageType">Message Type:</label>
                            <select id="messageType" onchange="updateMessageForm()">
                                <option value="setCounter">Set Counter</option>
                                <option value="incrementCounter">Increment Counter</option>
                                <option value="storeValue">Store Value</option>
                            </select>
                        </div>
                    </div>
                    
                    <div>
                        <div class="form-group" id="valueInput">
                            <label for="messageValue">Value:</label>
                            <input type="number" id="messageValue" placeholder="Enter value" />
                        </div>
                        
                        <div class="form-group">
                            <label for="gasLimit">Gas Limit:</label>
                            <input type="number" id="gasLimit" value="100000" />
                        </div>
                    </div>
                </div>
                
                <button class="btn btn-success" onclick="sendMessage()">Send Message</button>
                <button class="btn btn-secondary" onclick="simulateRelayerProcessing()">Simulate Relayer Processing</button>
            </div>

            <div class="section">
                <h2>üîê Admin Functions</h2>
                
                <div class="grid">
                    <div>
                        <div class="form-group">
                            <label for="relayerAddress">Relayer Address:</label>
                            <input type="text" id="relayerAddress" placeholder="0x..." />
                        </div>
                        
                        <button class="btn" onclick="addRelayer()">Add Relayer</button>
                        <button class="btn btn-danger" onclick="removeRelayer()">Remove Relayer</button>
                    </div>
                    
                    <div>
                        <div class="form-group">
                            <label for="chainId">Chain ID:</label>
                            <input type="number" id="chainId" placeholder="1, 137, 56..." />
                        </div>
                        
                        <button class="btn" onclick="enableChain()">Enable Chain</button>
                        <button class="btn btn-danger" onclick="disableChain()">Disable Chain</button>
                    </div>
                </div>
            </div>

            <div class="section">
                <h2>üìã Activity Log</h2>
                <button class="btn btn-secondary" onclick="clearLog()">Clear Log</button>
                <div class="log-container" id="logContainer">
                    <div class="log-entry log-info">Welcome to Cross-Chain Messaging Interface</div>
                    <div class="log-entry log-info">Connect your wallet and load contracts to get started</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let web3;
        let account;
        let messengerContract;
        let testTargetContract;

        const MESSENGER_ABI = [
            {
                "inputs": [],
                "name": "addRelayer",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [{"internalType": "address","name": "relayer","type": "address"}],
                "name": "addRelayer",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [{"internalType": "uint256","name": "chainId","type": "uint256"}],
                "name": "enableChain",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [{"internalType": "uint256","name": "chainId","type": "uint256"}],
                "name": "disableChain",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [{"internalType": "address","name": "relayer","type": "address"}],
                "name": "removeRelayer",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {"internalType": "uint256","name": "targetChain","type": "uint256"},
                    {"internalType": "address","name": "targetContract","type": "address"},
                    {"internalType": "bytes","name": "payload","type": "bytes"},
                    {"internalType": "uint256","name": "gasLimit","type": "uint256"}
                ],
                "name": "sendMessage",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {"internalType": "bytes32","name": "messageId","type": "bytes32"},
                    {"internalType": "uint256","name": "sourceChain","type": "uint256"},
                    {"internalType": "address","name": "sender","type": "address"},
                    {"internalType": "address","name": "targetContract","type": "address"},
                    {"internalType": "bytes","name": "payload","type": "bytes"},
                    {"internalType": "uint256","name": "nonce","type": "uint256"},
                    {"internalType": "uint256","name": "gasLimit","type": "uint256"},
                    {"internalType": "uint256","name": "expiry","type": "uint256"},
                    {"internalType": "bytes","name": "signature","type": "bytes"}
                ],
                "name": "processMessage",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [{"internalType": "uint256","name": "chainId","type": "uint256"}],
                "name": "getNextNonce",
                "outputs": [{"internalType": "uint256","name": "","type": "uint256"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "anonymous": false,
                "inputs": [
                    {"indexed": true,"internalType": "bytes32","name": "messageId","type": "bytes32"},
                    {"indexed": true,"internalType": "uint256","name": "targetChain","type": "uint256"},
                    {"indexed": true,"internalType": "address","name": "sender","type": "address"},
                    {"indexed": false,"internalType": "address","name": "targetContract","type": "address"},
                    {"indexed": false,"internalType": "bytes","name": "payload","type": "bytes"},
                    {"indexed": false,"internalType": "uint256","name": "nonce","type": "uint256"},
                    {"indexed": false,"internalType": "uint256","name": "gasLimit","type": "uint256"}
                ],
                "name": "MessageSent",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {"indexed": true,"internalType": "bytes32","name": "messageId","type": "bytes32"},
                    {"indexed": true,"internalType": "uint256","name": "sourceChain","type": "uint256"},
                    {"indexed": true,"internalType": "address","name": "sender","type": "address"},
                    {"indexed": false,"internalType": "address","name": "targetContract","type": "address"},
                    {"indexed": false,"internalType": "bool","name": "success","type": "bool"}
                ],
                "name": "MessageProcessed",
                "type": "event"
            }
        ];

        const TEST_TARGET_ABI = [
            {
                "inputs": [{"internalType": "uint256","name": "_counter","type": "uint256"}],
                "name": "setCounter",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "incrementCounter",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [{"internalType": "uint256","name": "_value","type": "uint256"}],
                "name": "storeValue",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "counter",
                "outputs": [{"internalType": "uint256","name": "","type": "uint256"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "storedValue",
                "outputs": [{"internalType": "uint256","name": "","type": "uint256"}],
                "stateMutability": "view",
                "type": "function"
            }
        ];

        async function connectWallet() {
            try {
                if (typeof window.ethereum !== 'undefined') {
                    web3 = new Web3(window.ethereum);
                    const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                    account = accounts[0];
                    
                    const networkId = await web3.eth.net.getId();
                    
                                    document.getElementById('walletStatus').textContent = `${account.substring(0, 6)}...${account.substring(38)}`;
                document.getElementById('walletStatus').style.color = '#28a745';
                document.getElementById('networkStatus').textContent = `Chain ID: ${networkId}`;
                
                if (networkId == 31337) {
                    document.getElementById('networkStatus').style.color = '#28a745';
                } else {
                    document.getElementById('networkStatus').style.color = '#ffc107';
                }
                
                logMessage('Wallet connected successfully', 'success');
                } else {
                    logMessage('MetaMask not detected. Please install MetaMask.', 'error');
                }
            } catch (error) {
                logMessage(`Error connecting wallet: ${error.message}`, 'error');
            }
        }

        async function loadContracts() {
            try {
                const messengerAddress = document.getElementById('messengerAddress').value;
                const testTargetAddress = document.getElementById('testTargetAddress').value;
                
                if (!messengerAddress || !testTargetAddress) {
                    logMessage('Please enter both contract addresses', 'error');
                    return;
                }
                
                messengerContract = new web3.eth.Contract(MESSENGER_ABI, messengerAddress);
                testTargetContract = new web3.eth.Contract(TEST_TARGET_ABI, testTargetAddress);
                
                document.getElementById('contractStatus').textContent = 'Loaded';
                document.getElementById('contractStatus').style.color = '#28a745';
                
                logMessage('Contracts loaded successfully', 'success');
                await refreshState();
            } catch (error) {
                logMessage(`Error loading contracts: ${error.message}`, 'error');
            }
        }

        async function refreshState() {
            try {
                if (!testTargetContract) {
                    logMessage('Please load contracts first', 'error');
                    return;
                }
                
                // Check if contract is deployed at the address
                const code = await web3.eth.getCode(testTargetContract.options.address);
                if (code === '0x') {
                    logMessage('TestTarget contract not deployed at the specified address', 'error');
                    return;
                }
                
                logMessage('Calling counter() method...', 'info');
                const counter = await testTargetContract.methods.counter().call();
                logMessage(`Counter value: ${counter}`, 'info');
                
                logMessage('Calling storedValue() method...', 'info');
                const storedValue = await testTargetContract.methods.storedValue().call();
                logMessage(`Stored value: ${storedValue}`, 'info');
                
                document.getElementById('counterValue').value = counter;
                document.getElementById('storedValue').value = storedValue;
                
                logMessage('Contract state refreshed successfully', 'success');
            } catch (error) {
                logMessage(`Error refreshing state: ${error.message}`, 'error');
                logMessage(`Contract address: ${testTargetContract?.options?.address}`, 'error');
                logMessage('Please check if the TestTarget contract is deployed correctly', 'error');
            }
        }

        function updateMessageForm() {
            const messageType = document.getElementById('messageType').value;
            const valueInput = document.getElementById('valueInput');
            
            if (messageType === 'incrementCounter') {
                valueInput.style.display = 'none';
            } else {
                valueInput.style.display = 'block';
            }
        }

        async function sendMessage() {
            try {
                if (!testTargetContract || !account) {
                    logMessage('Please connect wallet and load contracts first', 'error');
                    return;
                }
                
                // Check account balance
                const balance = await web3.eth.getBalance(account);
                const balanceEth = web3.utils.fromWei(balance, 'ether');
                logMessage(`Account balance: ${balanceEth} ETH`, 'info');
                
                if (parseFloat(balanceEth) < 0.01) {
                    logMessage('Warning: Low ETH balance. Make sure you have enough ETH for gas', 'error');
                }
                
                const targetChain = document.getElementById('targetChain').value;
                const messageType = document.getElementById('messageType').value;
                const messageValue = document.getElementById('messageValue').value;
                
                logMessage(`Executing ${messageType} directly on TestTarget contract...`, 'info');
                logMessage(`Contract address: ${testTargetContract.options.address}`, 'info');
                logMessage(`From account: ${account}`, 'info');
                
                let tx;
                
                try {
                    if (messageType === 'setCounter') {
                        if (!messageValue) {
                            logMessage('Please enter a value for setCounter', 'error');
                            return;
                        }
                        logMessage(`Calling setCounter(${messageValue})...`, 'info');
                        
                        // First test the call to make sure it works
                        logMessage('Testing setCounter call...', 'info');
                        await testTargetContract.methods.setCounter(messageValue).call({ from: account });
                        logMessage('Call test successful, sending transaction...', 'info');
                        
                        tx = await testTargetContract.methods.setCounter(messageValue).send({ 
                            from: account,
                            gas: 200000  // Fixed gas limit that works
                        });
                    } else if (messageType === 'incrementCounter') {
                        logMessage('Calling incrementCounter()...', 'info');
                        
                        logMessage('Testing incrementCounter call...', 'info');
                        await testTargetContract.methods.incrementCounter().call({ from: account });
                        logMessage('Call test successful, sending transaction...', 'info');
                        
                        tx = await testTargetContract.methods.incrementCounter().send({ 
                            from: account,
                            gas: 200000
                        });
                    } else if (messageType === 'storeValue') {
                        if (!messageValue) {
                            logMessage('Please enter a value for storeValue', 'error');
                            return;
                        }
                        logMessage(`Calling storeValue(${messageValue})...`, 'info');
                        
                        logMessage('Testing storeValue call...', 'info');
                        await testTargetContract.methods.storeValue(messageValue).call({ from: account });
                        logMessage('Call test successful, sending transaction...', 'info');
                        
                        tx = await testTargetContract.methods.storeValue(messageValue).send({ 
                            from: account,
                            gas: 200000
                        });
                    }
                    
                    logMessage(`Transaction successful! Hash: ${tx.transactionHash}`, 'success');
                    logMessage('Refreshing contract state...', 'info');
                    
                    // Auto-refresh state after successful transaction
                    setTimeout(async () => {
                        await refreshState();
                    }, 1000);
                    
                } catch (contractError) {
                    logMessage(`Contract call failed: ${contractError.message}`, 'error');
                    console.error('Contract error details:', contractError);
                    
                    // Try to get more specific error info
                    if (contractError.message.includes('revert')) {
                        logMessage('Transaction was reverted by the contract', 'error');
                    } else if (contractError.message.includes('gas')) {
                        logMessage('Gas-related error - try increasing gas limit', 'error');
                    } else if (contractError.message.includes('nonce')) {
                        logMessage('Nonce error - try refreshing and resending', 'error');
                    }
                }
                
            } catch (error) {
                logMessage(`Error executing message: ${error.message}`, 'error');
                logMessage('Check console for detailed error information', 'info');
                console.error('Detailed error:', error);
            }
        }

        async function simulateRelayerProcessing() {
            logMessage('Simulating relayer processing...', 'info');
            logMessage('In a real implementation, relayers would:', 'info');
            logMessage('1. Listen for MessageSent events', 'info');
            logMessage('2. Create and sign message proofs', 'info');
            logMessage('3. Call processMessage on target chain', 'info');
            logMessage('4. Handle gas estimation and retry logic', 'info');
            logMessage('Note: This demo runs on a single chain for simplicity', 'info');
        }

        async function addRelayer() {
            try {
                const relayerAddress = document.getElementById('relayerAddress').value;
                if (!relayerAddress) {
                    logMessage('Please enter relayer address', 'error');
                    return;
                }
                
                const tx = await messengerContract.methods.addRelayer(relayerAddress).send({ from: account });
                logMessage(`Relayer added! Transaction: ${tx.transactionHash}`, 'success');
            } catch (error) {
                logMessage(`Error adding relayer: ${error.message}`, 'error');
            }
        }

        async function removeRelayer() {
            try {
                const relayerAddress = document.getElementById('relayerAddress').value;
                if (!relayerAddress) {
                    logMessage('Please enter relayer address', 'error');
                    return;
                }
                
                const tx = await messengerContract.methods.removeRelayer(relayerAddress).send({ from: account });
                logMessage(`Relayer removed! Transaction: ${tx.transactionHash}`, 'success');
            } catch (error) {
                logMessage(`Error removing relayer: ${error.message}`, 'error');
            }
        }

        async function enableChain() {
            try {
                const chainId = document.getElementById('chainId').value;
                if (!chainId) {
                    logMessage('Please enter chain ID', 'error');
                    return;
                }
                
                const tx = await messengerContract.methods.enableChain(chainId).send({ from: account });
                logMessage(`Chain ${chainId} enabled! Transaction: ${tx.transactionHash}`, 'success');
            } catch (error) {
                logMessage(`Error enabling chain: ${error.message}`, 'error');
            }
        }

        async function disableChain() {
            try {
                const chainId = document.getElementById('chainId').value;
                if (!chainId) {
                    logMessage('Please enter chain ID', 'error');
                    return;
                }
                
                const tx = await messengerContract.methods.disableChain(chainId).send({ from: account });
                logMessage(`Chain ${chainId} disabled! Transaction: ${tx.transactionHash}`, 'success');
            } catch (error) {
                logMessage(`Error disabling chain: ${error.message}`, 'error');
            }
        }

        function logMessage(message, type = 'info') {
            const logContainer = document.getElementById('logContainer');
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry log-${type}`;
            logEntry.textContent = `[${timestamp}] ${message}`;
            logContainer.appendChild(logEntry);
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        function clearLog() {
            document.getElementById('logContainer').innerHTML = '';
            logMessage('Log cleared', 'info');
        }

        // Initialize form
        updateMessageForm();

        // Auto-check node status on page load
        checkNodeStatus();

        // Helper functions for automation
        async function checkNodeStatus() {
            const indicator = document.getElementById('nodeStatusIndicator');
            const statusElement = document.getElementById('nodeStatus');
            
            try {
                indicator.className = 'status-indicator loading';
                indicator.textContent = 'Checking...';
                
                // Try to connect to localhost:8545
                const response = await fetch('http://localhost:8545', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        jsonrpc: '2.0',
                        method: 'eth_chainId',
                        params: [],
                        id: 1
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.result === '0x7a69') { // 31337 in hex
                        indicator.className = 'status-indicator success';
                        indicator.textContent = '‚úÖ Hardhat node is running!';
                        statusElement.textContent = 'Running';
                        statusElement.style.color = '#28a745';
                        
                        // Auto-try to fetch contract addresses
                        setTimeout(() => tryFetchContractAddresses(), 1000);
                    } else {
                        throw new Error('Wrong network');
                    }
                } else {
                    throw new Error('Connection failed');
                }
            } catch (error) {
                indicator.className = 'status-indicator error';
                indicator.textContent = '‚ùå Hardhat node not running. Run: npx hardhat node';
                statusElement.textContent = 'Not Running';
                statusElement.style.color = '#dc3545';
            }
        }

        async function tryFetchContractAddresses() {
            const indicator = document.getElementById('deployStatusIndicator');
            
            try {
                indicator.className = 'status-indicator loading';
                indicator.textContent = 'Checking for deployed contracts...';
                
                // Common deployment addresses (Hardhat deploys to these usually)
                const commonAddresses = [
                    '0x5FbDB2315678afecb367f032d93F642f64180aa3',
                    '0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512',
                    '0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0',
                    '0xCf7Ed3AccA5a467e9e704C703E8D87F634fB0Fc9'
                ];
                
                const tempWeb3 = new Web3('http://localhost:8545');
                let messengerAddr = null;
                let testTargetAddr = null;
                
                // Check each address to see what's deployed
                for (const addr of commonAddresses) {
                    try {
                        const code = await tempWeb3.eth.getCode(addr);
                        if (code !== '0x') {
                            // Try to determine which contract this is
                            const contract = new tempWeb3.eth.Contract(TEST_TARGET_ABI, addr);
                            try {
                                await contract.methods.counter().call();
                                testTargetAddr = addr;
                                logMessage(`Found TestTarget at: ${addr}`, 'success');
                            } catch {
                                // Probably the messenger contract
                                messengerAddr = addr;
                                logMessage(`Found CrossChainMessenger at: ${addr}`, 'success');
                            }
                        }
                    } catch (e) {
                        // Continue checking other addresses
                    }
                }
                
                if (messengerAddr && testTargetAddr) {
                    document.getElementById('messengerAddress').value = messengerAddr;
                    document.getElementById('testTargetAddress').value = testTargetAddr;
                    
                    indicator.className = 'status-indicator success';
                    indicator.textContent = '‚úÖ Contract addresses auto-detected!';
                    
                    logMessage('Contract addresses auto-populated!', 'success');
                    logMessage(`CrossChainMessenger: ${messengerAddr}`, 'info');
                    logMessage(`TestTarget: ${testTargetAddr}`, 'info');
                    
                    // Auto-load contracts
                    setTimeout(() => loadContracts(), 1000);
                    
                } else {
                    indicator.className = 'status-indicator error';
                    indicator.textContent = '‚ùå Contracts not found. Please deploy them first.';
                }
                
            } catch (error) {
                indicator.className = 'status-indicator error';
                indicator.textContent = '‚ùå Error checking contracts: ' + error.message;
            }
        }

        async function addHardhatNetwork() {
            try {
                if (typeof window.ethereum !== 'undefined') {
                    await window.ethereum.request({
                        method: 'wallet_addEthereumChain',
                        params: [{
                            chainId: '0x7a69', // 31337 in hex
                            chainName: 'Hardhat Local',
                            nativeCurrency: {
                                name: 'Ethereum',
                                symbol: 'ETH',
                                decimals: 18
                            },
                            rpcUrls: ['http://localhost:8545'],
                            blockExplorerUrls: null
                        }]
                    });
                    logMessage('‚úÖ Hardhat network added to MetaMask!', 'success');
                } else {
                    logMessage('‚ùå MetaMask not detected', 'error');
                }
            } catch (error) {
                logMessage(`Error adding network: ${error.message}`, 'error');
            }
        }

        async function copyTestAccount() {
            const privateKey = '0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80';
            const indicator = document.getElementById('accountCopyIndicator');
            
            try {
                await navigator.clipboard.writeText(privateKey);
                indicator.className = 'status-indicator success';
                indicator.textContent = '‚úÖ Private key copied to clipboard!';
                logMessage('Test account private key copied to clipboard', 'success');
                
                setTimeout(() => {
                    indicator.textContent = '';
                    indicator.className = '';
                }, 3000);
            } catch (error) {
                indicator.className = 'status-indicator error';
                indicator.textContent = '‚ùå Failed to copy. Copy manually from above.';
            }
        }
    </script>
</body>
</html> 